"""
SuperNova AI Compliance Framework
Comprehensive compliance hardening for financial regulations (FINRA, SEC, GDPR, SOX)
"""

import os
import json
import hashlib
import uuid
from datetime import datetime, timedelta
from typing import Dict, Any, List, Optional, Set, Tuple, Union
from enum import Enum
from dataclasses import dataclass, asdict, field
import asyncio
import logging
from collections import defaultdict, deque
import re
from pathlib import Path

from .security_config import security_settings
from .security_logger import security_logger, SecurityEventLevel, SECURITY_EVENT_TYPES
from .advanced_encryption import advanced_encryption_manager, DataClassification

logger = logging.getLogger(__name__)


class ComplianceRegulation(str, Enum):
    """Supported compliance regulations"""
    GDPR = "gdpr"                  # General Data Protection Regulation
    CCPA = "ccpa"                  # California Consumer Privacy Act
    SOX = "sox"                    # Sarbanes-Oxley Act
    FINRA = "finra"               # Financial Industry Regulatory Authority
    SEC = "sec"                   # Securities and Exchange Commission
    PCI_DSS = "pci_dss"          # Payment Card Industry Data Security Standard
    HIPAA = "hipaa"               # Health Insurance Portability and Accountability Act
    ISO_27001 = "iso_27001"       # Information Security Management
    SOC2 = "soc2"                 # Service Organization Control 2


class DataSubjectRight(str, Enum):
    """GDPR Data Subject Rights"""
    ACCESS = "access"                        # Right to access
    RECTIFICATION = "rectification"          # Right to rectification
    ERASURE = "erasure"                     # Right to erasure (right to be forgotten)
    RESTRICT_PROCESSING = "restrict_processing"  # Right to restrict processing
    DATA_PORTABILITY = "data_portability"    # Right to data portability
    OBJECT = "object"                       # Right to object
    AUTOMATED_DECISION = "automated_decision"  # Rights related to automated decision making


class ConsentType(str, Enum):
    """Types of data processing consent"""
    EXPLICIT = "explicit"           # Explicit consent required
    IMPLIED = "implied"            # Implied consent acceptable
    LEGITIMATE_INTEREST = "legitimate_interest"  # Legitimate interest basis
    CONTRACTUAL = "contractual"    # Contractual necessity
    LEGAL_OBLIGATION = "legal_obligation"  # Legal obligation


class AuditEventType(str, Enum):
    """Audit event types for compliance"""
    DATA_ACCESS = "data_access"
    DATA_MODIFICATION = "data_modification"
    DATA_EXPORT = "data_export"
    DATA_DELETION = "data_deletion"
    CONSENT_GRANTED = "consent_granted"
    CONSENT_WITHDRAWN = "consent_withdrawn"
    PRIVACY_POLICY_UPDATE = "privacy_policy_update"
    SECURITY_INCIDENT = "security_incident"
    COMPLIANCE_VIOLATION = "compliance_violation"
    REGULATORY_REPORT = "regulatory_report"


@dataclass
class DataProcessingRecord:
    """Record of data processing activity"""
    record_id: str
    user_id: str
    data_category: str
    processing_purpose: str
    legal_basis: ConsentType
    data_fields: List[str]
    retention_period: int  # days
    processed_at: datetime
    processor_id: str
    cross_border_transfer: bool = False
    automated_decision_making: bool = False
    
    def __post_init__(self):
        if not self.record_id:
            self.record_id = str(uuid.uuid4())


@dataclass
class ConsentRecord:
    """User consent record"""
    consent_id: str
    user_id: str
    consent_type: ConsentType
    purposes: List[str]
    granted_at: datetime
    expires_at: Optional[datetime]
    withdrawn_at: Optional[datetime] = None
    version: str = "1.0"
    ip_address: Optional[str] = None
    user_agent: Optional[str] = None
    explicit_consent: bool = True
    
    def is_valid(self) -> bool:
        current_time = datetime.now()
        return (self.withdrawn_at is None and 
                (self.expires_at is None or self.expires_at > current_time))


@dataclass
class ComplianceViolation:
    """Compliance violation record"""
    violation_id: str
    regulation: ComplianceRegulation
    violation_type: str
    severity: str  # low, medium, high, critical
    description: str
    detected_at: datetime
    user_id: Optional[str] = None
    data_involved: Optional[List[str]] = None
    remediation_required: bool = True
    resolved_at: Optional[datetime] = None
    resolution_notes: Optional[str] = None


@dataclass
class RegulatoryReport:
    """Regulatory compliance report"""
    report_id: str
    regulation: ComplianceRegulation
    report_type: str
    period_start: datetime
    period_end: datetime
    generated_at: datetime
    data: Dict[str, Any]
    status: str = "draft"  # draft, submitted, approved
    submitted_at: Optional[datetime] = None
    submitted_by: Optional[str] = None


class ComplianceFramework:
    """
    Comprehensive compliance framework for financial and privacy regulations
    """
    
    def __init__(self):
        self.processing_records: Dict[str, DataProcessingRecord] = {}
        self.consent_records: Dict[str, ConsentRecord] = {}
        self.violation_records: Dict[str, ComplianceViolation] = {}
        self.regulatory_reports: Dict[str, RegulatoryReport] = {}
        
        # Compliance configuration
        self.enabled_regulations = self._get_enabled_regulations()
        self.data_retention_policies = self._initialize_retention_policies()
        self.breach_notification_requirements = self._initialize_breach_requirements()
        
        # GDPR specific settings
        self.gdpr_lawful_bases = {
            "user_consent": ConsentType.EXPLICIT,
            "contract_performance": ConsentType.CONTRACTUAL,
            "legal_compliance": ConsentType.LEGAL_OBLIGATION,
            "vital_interests": ConsentType.LEGITIMATE_INTEREST,
            "public_task": ConsentType.LEGITIMATE_INTEREST,
            "legitimate_interests": ConsentType.LEGITIMATE_INTEREST
        }
        
        # Financial compliance settings
        self.finra_categories = {\n            "customer_data": 6 * 365,      # 6 years\n            "transaction_records": 3 * 365, # 3 years\n            "communications": 3 * 365,      # 3 years\n            "complaints": 4 * 365,          # 4 years\n            "research_reports": 3 * 365     # 3 years\n        }\n        \n        self.sec_requirements = {\n            "investment_adviser_records": 5 * 365,  # 5 years\n            "client_agreements": 5 * 365,          # 5 years\n            "performance_data": 5 * 365,           # 5 years\n            "marketing_materials": 5 * 365,        # 5 years\n            "compliance_policies": 5 * 365         # 5 years\n        }\n        \n        # Start background compliance tasks\n        asyncio.create_task(self._compliance_monitoring_task())\n        asyncio.create_task(self._data_retention_task())\n        asyncio.create_task(self._consent_expiry_task())\n    \n    def _get_enabled_regulations(self) -> Set[ComplianceRegulation]:\n        \"\"\"Get enabled compliance regulations from configuration\"\"\"\n        enabled = set()\n        \n        if security_settings.GDPR_COMPLIANCE_ENABLED:\n            enabled.add(ComplianceRegulation.GDPR)\n        if security_settings.CCPA_COMPLIANCE_ENABLED:\n            enabled.add(ComplianceRegulation.CCPA)\n        if security_settings.SOC2_COMPLIANCE_ENABLED:\n            enabled.add(ComplianceRegulation.SOC2)\n        if security_settings.PCI_DSS_COMPLIANCE_ENABLED:\n            enabled.add(ComplianceRegulation.PCI_DSS)\n        if security_settings.FINRA_COMPLIANCE_ENABLED:\n            enabled.add(ComplianceRegulation.FINRA)\n        \n        # Add SEC compliance for financial services\n        enabled.add(ComplianceRegulation.SEC)\n        \n        return enabled\n    \n    def _initialize_retention_policies(self) -> Dict[str, int]:\n        \"\"\"Initialize data retention policies by category\"\"\"\n        return {\n            # GDPR categories\n            \"personal_data\": security_settings.USER_DATA_RETENTION_DAYS,\n            \"financial_data\": security_settings.TRANSACTION_DATA_RETENTION_DAYS,\n            \"audit_logs\": security_settings.LOG_DATA_RETENTION_DAYS,\n            \"communication_logs\": 3 * 365,  # 3 years\n            \"marketing_data\": 2 * 365,      # 2 years\n            \n            # Financial regulatory categories\n            \"customer_records\": 6 * 365,     # FINRA requirement\n            \"transaction_records\": 7 * 365,  # SOX requirement\n            \"investment_advice\": 5 * 365,    # SEC requirement\n            \"compliance_records\": 7 * 365,   # SOX requirement\n            \n            # Security categories\n            \"security_logs\": 7 * 365,        # 7 years for forensics\n            \"incident_reports\": 7 * 365,     # 7 years\n            \"access_logs\": 2 * 365,          # 2 years\n        }\n    \n    def _initialize_breach_requirements(self) -> Dict[ComplianceRegulation, Dict[str, Any]]:\n        \"\"\"Initialize breach notification requirements\"\"\"\n        return {\n            ComplianceRegulation.GDPR: {\n                \"authority_notification_hours\": 72,\n                \"subject_notification_required\": True,\n                \"high_risk_threshold\": True,\n                \"documentation_required\": True\n            },\n            ComplianceRegulation.CCPA: {\n                \"authority_notification_hours\": None,  # No specific requirement\n                \"subject_notification_required\": True,\n                \"affects_500_plus\": True,\n                \"without_unreasonable_delay\": True\n            },\n            ComplianceRegulation.SEC: {\n                \"authority_notification_hours\": 48,\n                \"cybersecurity_incident\": True,\n                \"client_notification_required\": True,\n                \"material_impact_assessment\": True\n            },\n            ComplianceRegulation.FINRA: {\n                \"authority_notification_hours\": 24,\n                \"member_firm_obligation\": True,\n                \"customer_notification\": True,\n                \"suspicious_activity_report\": True\n            }\n        }\n    \n    async def record_data_processing(\n        self,\n        user_id: str,\n        data_category: str,\n        processing_purpose: str,\n        data_fields: List[str],\n        legal_basis: ConsentType = ConsentType.LEGITIMATE_INTEREST,\n        processor_id: str = \"supernova_ai\",\n        cross_border: bool = False,\n        automated_decision: bool = False\n    ) -> str:\n        \"\"\"Record data processing activity for compliance\"\"\"\n        \n        # Determine retention period\n        retention_days = self.data_retention_policies.get(data_category, 365)\n        \n        # Create processing record\n        record = DataProcessingRecord(\n            record_id=str(uuid.uuid4()),\n            user_id=user_id,\n            data_category=data_category,\n            processing_purpose=processing_purpose,\n            legal_basis=legal_basis,\n            data_fields=data_fields,\n            retention_period=retention_days,\n            processed_at=datetime.now(),\n            processor_id=processor_id,\n            cross_border_transfer=cross_border,\n            automated_decision_making=automated_decision\n        )\n        \n        self.processing_records[record.record_id] = record\n        \n        # Check compliance requirements\n        await self._validate_processing_compliance(record)\n        \n        # Log the processing activity\n        security_logger.log_security_event(\n            event_type=SECURITY_EVENT_TYPES[\"DATA_ACCESS\"],\n            level=SecurityEventLevel.INFO,\n            user_id=user_id,\n            details={\n                \"processing_record_id\": record.record_id,\n                \"data_category\": data_category,\n                \"purpose\": processing_purpose,\n                \"legal_basis\": legal_basis.value,\n                \"cross_border_transfer\": cross_border,\n                \"automated_decision_making\": automated_decision\n            }\n        )\n        \n        return record.record_id\n    \n    async def record_consent(\n        self,\n        user_id: str,\n        consent_type: ConsentType,\n        purposes: List[str],\n        ip_address: Optional[str] = None,\n        user_agent: Optional[str] = None,\n        expires_in_days: Optional[int] = None\n    ) -> str:\n        \"\"\"Record user consent for data processing\"\"\"\n        \n        consent_id = str(uuid.uuid4())\n        expires_at = None\n        if expires_in_days:\n            expires_at = datetime.now() + timedelta(days=expires_in_days)\n        \n        consent = ConsentRecord(\n            consent_id=consent_id,\n            user_id=user_id,\n            consent_type=consent_type,\n            purposes=purposes,\n            granted_at=datetime.now(),\n            expires_at=expires_at,\n            ip_address=ip_address,\n            user_agent=user_agent\n        )\n        \n        self.consent_records[consent_id] = consent\n        \n        # Log consent event\n        security_logger.log_security_event(\n            event_type=\"CONSENT_GRANTED\",\n            level=SecurityEventLevel.INFO,\n            user_id=user_id,\n            client_ip=ip_address,\n            details={\n                \"consent_id\": consent_id,\n                \"consent_type\": consent_type.value,\n                \"purposes\": purposes,\n                \"expires_at\": expires_at.isoformat() if expires_at else None\n            }\n        )\n        \n        return consent_id\n    \n    async def withdraw_consent(self, consent_id: str, user_id: str) -> bool:\n        \"\"\"Withdraw user consent\"\"\"\n        \n        consent = self.consent_records.get(consent_id)\n        if not consent or consent.user_id != user_id:\n            return False\n        \n        consent.withdrawn_at = datetime.now()\n        \n        # Log consent withdrawal\n        security_logger.log_security_event(\n            event_type=\"CONSENT_WITHDRAWN\",\n            level=SecurityEventLevel.INFO,\n            user_id=user_id,\n            details={\n                \"consent_id\": consent_id,\n                \"withdrawn_at\": consent.withdrawn_at.isoformat(),\n                \"original_purposes\": consent.purposes\n            }\n        )\n        \n        # Check if any ongoing processing needs to be stopped\n        await self._handle_consent_withdrawal(user_id, consent.purposes)\n        \n        return True\n    \n    async def handle_data_subject_request(\n        self,\n        user_id: str,\n        request_type: DataSubjectRight,\n        specific_data: Optional[List[str]] = None,\n        verification_token: Optional[str] = None\n    ) -> Dict[str, Any]:\n        \"\"\"Handle GDPR data subject rights requests\"\"\"\n        \n        request_id = str(uuid.uuid4())\n        \n        if ComplianceRegulation.GDPR not in self.enabled_regulations:\n            raise ValueError(\"GDPR compliance not enabled\")\n        \n        # Verify request authenticity (simplified)\n        if not await self._verify_data_subject_identity(user_id, verification_token):\n            raise ValueError(\"Unable to verify data subject identity\")\n        \n        result = {\n            \"request_id\": request_id,\n            \"user_id\": user_id,\n            \"request_type\": request_type.value,\n            \"processed_at\": datetime.now().isoformat(),\n            \"status\": \"processing\"\n        }\n        \n        try:\n            if request_type == DataSubjectRight.ACCESS:\n                result.update(await self._handle_access_request(user_id, specific_data))\n            \n            elif request_type == DataSubjectRight.ERASURE:\n                result.update(await self._handle_erasure_request(user_id, specific_data))\n            \n            elif request_type == DataSubjectRight.RECTIFICATION:\n                result.update(await self._handle_rectification_request(user_id, specific_data))\n            \n            elif request_type == DataSubjectRight.DATA_PORTABILITY:\n                result.update(await self._handle_portability_request(user_id, specific_data))\n            \n            elif request_type == DataSubjectRight.RESTRICT_PROCESSING:\n                result.update(await self._handle_restriction_request(user_id, specific_data))\n            \n            elif request_type == DataSubjectRight.OBJECT:\n                result.update(await self._handle_objection_request(user_id, specific_data))\n            \n            result[\"status\"] = \"completed\"\n            \n        except Exception as e:\n            result[\"status\"] = \"failed\"\n            result[\"error\"] = str(e)\n        \n        # Log the request\n        security_logger.log_security_event(\n            event_type=\"DATA_SUBJECT_REQUEST\",\n            level=SecurityEventLevel.INFO,\n            user_id=user_id,\n            details={\n                \"request_id\": request_id,\n                \"request_type\": request_type.value,\n                \"status\": result[\"status\"],\n                \"specific_data\": specific_data\n            }\n        )\n        \n        return result\n    \n    async def report_compliance_violation(\n        self,\n        regulation: ComplianceRegulation,\n        violation_type: str,\n        severity: str,\n        description: str,\n        user_id: Optional[str] = None,\n        data_involved: Optional[List[str]] = None\n    ) -> str:\n        \"\"\"Report a compliance violation\"\"\"\n        \n        violation_id = str(uuid.uuid4())\n        \n        violation = ComplianceViolation(\n            violation_id=violation_id,\n            regulation=regulation,\n            violation_type=violation_type,\n            severity=severity,\n            description=description,\n            detected_at=datetime.now(),\n            user_id=user_id,\n            data_involved=data_involved\n        )\n        \n        self.violation_records[violation_id] = violation\n        \n        # Determine if breach notification is required\n        if severity in [\"high\", \"critical\"]:\n            await self._assess_breach_notification_requirement(violation)\n        \n        # Log the violation\n        security_logger.log_security_event(\n            event_type=SECURITY_EVENT_TYPES[\"SECURITY_VIOLATION\"],\n            level=SecurityEventLevel.ERROR if severity in [\"high\", \"critical\"] else SecurityEventLevel.WARNING,\n            user_id=user_id,\n            details={\n                \"violation_id\": violation_id,\n                \"regulation\": regulation.value,\n                \"violation_type\": violation_type,\n                \"severity\": severity,\n                \"description\": description[:200]  # Truncate for logging\n            }\n        )\n        \n        return violation_id\n    \n    async def generate_compliance_report(\n        self,\n        regulation: ComplianceRegulation,\n        report_type: str,\n        period_start: datetime,\n        period_end: datetime\n    ) -> str:\n        \"\"\"Generate regulatory compliance report\"\"\"\n        \n        report_id = str(uuid.uuid4())\n        \n        # Collect relevant data for the reporting period\n        report_data = await self._collect_compliance_data(\n            regulation, report_type, period_start, period_end\n        )\n        \n        report = RegulatoryReport(\n            report_id=report_id,\n            regulation=regulation,\n            report_type=report_type,\n            period_start=period_start,\n            period_end=period_end,\n            generated_at=datetime.now(),\n            data=report_data\n        )\n        \n        self.regulatory_reports[report_id] = report\n        \n        # Log report generation\n        security_logger.log_security_event(\n            event_type=\"REGULATORY_REPORT_GENERATED\",\n            level=SecurityEventLevel.INFO,\n            details={\n                \"report_id\": report_id,\n                \"regulation\": regulation.value,\n                \"report_type\": report_type,\n                \"period_start\": period_start.isoformat(),\n                \"period_end\": period_end.isoformat()\n            }\n        )\n        \n        return report_id\n    \n    async def _validate_processing_compliance(self, record: DataProcessingRecord):\n        \"\"\"Validate data processing against compliance requirements\"\"\"\n        \n        violations = []\n        \n        # GDPR compliance checks\n        if ComplianceRegulation.GDPR in self.enabled_regulations:\n            # Check for valid consent if required\n            if record.legal_basis == ConsentType.EXPLICIT:\n                valid_consent = await self._check_valid_consent(record.user_id, record.processing_purpose)\n                if not valid_consent:\n                    violations.append((\"gdpr_consent_missing\", \"No valid consent for explicit consent requirement\"))\n            \n            # Check cross-border transfer compliance\n            if record.cross_border_transfer:\n                # In production, check adequacy decisions or appropriate safeguards\n                pass\n        \n        # Financial regulation compliance checks\n        if ComplianceRegulation.FINRA in self.enabled_regulations:\n            # Check customer data handling requirements\n            if record.data_category == \"customer_data\":\n                if record.retention_period < self.finra_categories[\"customer_data\"]:\n                    violations.append((\"finra_retention_insufficient\", \"Customer data retention period too short\"))\n        \n        # Report any violations found\n        for violation_type, description in violations:\n            await self.report_compliance_violation(\n                ComplianceRegulation.GDPR if violation_type.startswith(\"gdpr\") else ComplianceRegulation.FINRA,\n                violation_type,\n                \"medium\",\n                description,\n                record.user_id\n            )\n    \n    async def _check_valid_consent(self, user_id: str, purpose: str) -> bool:\n        \"\"\"Check if valid consent exists for processing purpose\"\"\"\n        \n        for consent in self.consent_records.values():\n            if (consent.user_id == user_id and \n                purpose in consent.purposes and \n                consent.is_valid()):\n                return True\n        \n        return False\n    \n    async def _handle_consent_withdrawal(self, user_id: str, withdrawn_purposes: List[str]):\n        \"\"\"Handle actions required after consent withdrawal\"\"\"\n        \n        # Find processing activities that relied on the withdrawn consent\n        affected_processing = [\n            record for record in self.processing_records.values()\n            if (record.user_id == user_id and \n                record.processing_purpose in withdrawn_purposes and\n                record.legal_basis == ConsentType.EXPLICIT)\n        ]\n        \n        # Log affected processing activities\n        if affected_processing:\n            security_logger.log_security_event(\n                event_type=\"PROCESSING_AFFECTED_BY_CONSENT_WITHDRAWAL\",\n                level=SecurityEventLevel.WARNING,\n                user_id=user_id,\n                details={\n                    \"withdrawn_purposes\": withdrawn_purposes,\n                    \"affected_processing_count\": len(affected_processing),\n                    \"processing_records\": [r.record_id for r in affected_processing]\n                }\n            )\n    \n    async def _handle_access_request(self, user_id: str, specific_data: Optional[List[str]]) -> Dict[str, Any]:\n        \"\"\"Handle GDPR Article 15 - Right of access\"\"\"\n        \n        # Collect all personal data for the user\n        user_data = {\n            \"processing_activities\": [],\n            \"consents\": [],\n            \"data_categories\": set(),\n            \"retention_periods\": {},\n            \"third_party_sharing\": []\n        }\n        \n        # Get processing records\n        for record in self.processing_records.values():\n            if record.user_id == user_id:\n                user_data[\"processing_activities\"].append({\n                    \"purpose\": record.processing_purpose,\n                    \"legal_basis\": record.legal_basis.value,\n                    \"data_fields\": record.data_fields,\n                    \"processed_at\": record.processed_at.isoformat(),\n                    \"retention_period_days\": record.retention_period\n                })\n                user_data[\"data_categories\"].update(record.data_fields)\n                user_data[\"retention_periods\"][record.data_category] = record.retention_period\n        \n        # Get consent records\n        for consent in self.consent_records.values():\n            if consent.user_id == user_id:\n                user_data[\"consents\"].append({\n                    \"purposes\": consent.purposes,\n                    \"granted_at\": consent.granted_at.isoformat(),\n                    \"expires_at\": consent.expires_at.isoformat() if consent.expires_at else None,\n                    \"withdrawn_at\": consent.withdrawn_at.isoformat() if consent.withdrawn_at else None,\n                    \"status\": \"active\" if consent.is_valid() else \"inactive\"\n                })\n        \n        user_data[\"data_categories\"] = list(user_data[\"data_categories\"])\n        \n        return {\"personal_data_report\": user_data}\n    \n    async def _handle_erasure_request(self, user_id: str, specific_data: Optional[List[str]]) -> Dict[str, Any]:\n        \"\"\"Handle GDPR Article 17 - Right to erasure\"\"\"\n        \n        erasure_summary = {\n            \"data_erased\": [],\n            \"data_retained\": [],\n            \"retention_reasons\": {}\n        }\n        \n        # Check each processing record for erasure eligibility\n        for record in self.processing_records.values():\n            if record.user_id == user_id:\n                # Check if legal basis still applies\n                can_erase = True\n                retention_reason = None\n                \n                # Financial regulations may require retention\n                if record.data_category in self.finra_categories:\n                    retention_period = self.finra_categories[record.data_category]\n                    days_since_processing = (datetime.now() - record.processed_at).days\n                    \n                    if days_since_processing < retention_period:\n                        can_erase = False\n                        retention_reason = f\"FINRA requires retention for {retention_period} days\"\n                \n                if can_erase:\n                    erasure_summary[\"data_erased\"].extend(record.data_fields)\n                    # In production, actually delete the data here\n                else:\n                    erasure_summary[\"data_retained\"].extend(record.data_fields)\n                    erasure_summary[\"retention_reasons\"][record.data_category] = retention_reason\n        \n        return erasure_summary\n    \n    async def _handle_rectification_request(self, user_id: str, specific_data: Optional[List[str]]) -> Dict[str, Any]:\n        \"\"\"Handle GDPR Article 16 - Right to rectification\"\"\"\n        \n        return {\n            \"message\": \"Data rectification request received. Please provide corrected data through appropriate channels.\",\n            \"next_steps\": \"Contact customer service with verification documents and corrected information\"\n        }\n    \n    async def _handle_portability_request(self, user_id: str, specific_data: Optional[List[str]]) -> Dict[str, Any]:\n        \"\"\"Handle GDPR Article 20 - Right to data portability\"\"\"\n        \n        portable_data = {}\n        \n        # Collect data that can be ported (structured, commonly used formats)\n        for record in self.processing_records.values():\n            if (record.user_id == user_id and \n                record.legal_basis in [ConsentType.EXPLICIT, ConsentType.CONTRACTUAL]):\n                \n                category = record.data_category\n                if category not in portable_data:\n                    portable_data[category] = []\n                \n                portable_data[category].append({\n                    \"purpose\": record.processing_purpose,\n                    \"data_fields\": record.data_fields,\n                    \"processed_at\": record.processed_at.isoformat()\n                })\n        \n        return {\n            \"portable_data\": portable_data,\n            \"format\": \"JSON\",\n            \"export_generated_at\": datetime.now().isoformat()\n        }\n    \n    async def _handle_restriction_request(self, user_id: str, specific_data: Optional[List[str]]) -> Dict[str, Any]:\n        \"\"\"Handle GDPR Article 18 - Right to restriction of processing\"\"\"\n        \n        return {\n            \"message\": \"Processing restriction request received\",\n            \"status\": \"Processing activities will be restricted pending review\",\n            \"review_period\": \"30 days\"\n        }\n    \n    async def _handle_objection_request(self, user_id: str, specific_data: Optional[List[str]]) -> Dict[str, Any]:\n        \"\"\"Handle GDPR Article 21 - Right to object\"\"\"\n        \n        return {\n            \"message\": \"Objection to processing received\",\n            \"status\": \"Processing based on legitimate interests will be reviewed\",\n            \"review_period\": \"30 days\"\n        }\n    \n    async def _verify_data_subject_identity(self, user_id: str, verification_token: Optional[str]) -> bool:\n        \"\"\"Verify data subject identity for rights requests\"\"\"\n        # Simplified verification - in production, implement proper identity verification\n        return True\n    \n    async def _assess_breach_notification_requirement(self, violation: ComplianceViolation):\n        \"\"\"Assess if a breach requires regulatory notification\"\"\"\n        \n        requirements = self.breach_notification_requirements.get(violation.regulation)\n        if not requirements:\n            return\n        \n        # Check if breach notification is required\n        notification_required = False\n        \n        if violation.regulation == ComplianceRegulation.GDPR:\n            # GDPR requires notification for breaches likely to result in risk\n            if violation.severity in [\"high\", \"critical\"]:\n                notification_required = True\n        \n        elif violation.regulation == ComplianceRegulation.SEC:\n            # SEC requires notification for material cybersecurity incidents\n            if \"cybersecurity\" in violation.violation_type.lower():\n                notification_required = True\n        \n        if notification_required:\n            # Create breach notification task\n            await self._create_breach_notification(violation, requirements)\n    \n    async def _create_breach_notification(self, violation: ComplianceViolation, requirements: Dict[str, Any]):\n        \"\"\"Create breach notification for regulatory authorities\"\"\"\n        \n        notification_id = str(uuid.uuid4())\n        \n        # Calculate notification deadline\n        deadline = None\n        if requirements.get(\"authority_notification_hours\"):\n            deadline = violation.detected_at + timedelta(hours=requirements[\"authority_notification_hours\"])\n        \n        security_logger.log_security_event(\n            event_type=\"BREACH_NOTIFICATION_REQUIRED\",\n            level=SecurityEventLevel.CRITICAL,\n            details={\n                \"notification_id\": notification_id,\n                \"violation_id\": violation.violation_id,\n                \"regulation\": violation.regulation.value,\n                \"deadline\": deadline.isoformat() if deadline else None,\n                \"requirements\": requirements\n            }\n        )\n        \n        logger.critical(f\"BREACH NOTIFICATION REQUIRED: {notification_id} for violation {violation.violation_id}\")\n    \n    async def _collect_compliance_data(\n        self,\n        regulation: ComplianceRegulation,\n        report_type: str,\n        period_start: datetime,\n        period_end: datetime\n    ) -> Dict[str, Any]:\n        \"\"\"Collect data for compliance reporting\"\"\"\n        \n        data = {\n            \"period\": {\n                \"start\": period_start.isoformat(),\n                \"end\": period_end.isoformat()\n            },\n            \"regulation\": regulation.value,\n            \"report_type\": report_type\n        }\n        \n        if regulation == ComplianceRegulation.GDPR:\n            data.update(await self._collect_gdpr_data(period_start, period_end))\n        elif regulation == ComplianceRegulation.FINRA:\n            data.update(await self._collect_finra_data(period_start, period_end))\n        elif regulation == ComplianceRegulation.SEC:\n            data.update(await self._collect_sec_data(period_start, period_end))\n        \n        return data\n    \n    async def _collect_gdpr_data(self, start: datetime, end: datetime) -> Dict[str, Any]:\n        \"\"\"Collect GDPR-specific compliance data\"\"\"\n        \n        period_processing = [\n            record for record in self.processing_records.values()\n            if start <= record.processed_at <= end\n        ]\n        \n        period_consents = [\n            consent for consent in self.consent_records.values()\n            if start <= consent.granted_at <= end\n        ]\n        \n        period_violations = [\n            violation for violation in self.violation_records.values()\n            if (violation.regulation == ComplianceRegulation.GDPR and \n                start <= violation.detected_at <= end)\n        ]\n        \n        return {\n            \"processing_activities_count\": len(period_processing),\n            \"consent_records_count\": len(period_consents),\n            \"violations_count\": len(period_violations),\n            \"data_categories_processed\": list(set(r.data_category for r in period_processing)),\n            \"legal_basis_distribution\": {\n                basis.value: len([r for r in period_processing if r.legal_basis == basis])\n                for basis in ConsentType\n            },\n            \"cross_border_transfers\": len([r for r in period_processing if r.cross_border_transfer]),\n            \"automated_decision_making\": len([r for r in period_processing if r.automated_decision_making])\n        }\n    \n    async def _collect_finra_data(self, start: datetime, end: datetime) -> Dict[str, Any]:\n        \"\"\"Collect FINRA-specific compliance data\"\"\"\n        \n        period_records = [\n            record for record in self.processing_records.values()\n            if (start <= record.processed_at <= end and \n                record.data_category in self.finra_categories)\n        ]\n        \n        return {\n            \"customer_records_processed\": len([r for r in period_records if r.data_category == \"customer_data\"]),\n            \"transaction_records_processed\": len([r for r in period_records if r.data_category == \"transaction_records\"]),\n            \"communications_recorded\": len([r for r in period_records if r.data_category == \"communications\"]),\n            \"complaints_handled\": len([r for r in period_records if r.data_category == \"complaints\"]),\n            \"retention_compliance\": self._check_retention_compliance(period_records)\n        }\n    \n    async def _collect_sec_data(self, start: datetime, end: datetime) -> Dict[str, Any]:\n        \"\"\"Collect SEC-specific compliance data\"\"\"\n        \n        period_records = [\n            record for record in self.processing_records.values()\n            if (start <= record.processed_at <= end and \n                record.data_category in self.sec_requirements)\n        ]\n        \n        return {\n            \"investment_adviser_records\": len([r for r in period_records if \"adviser\" in r.data_category]),\n            \"client_agreements_processed\": len([r for r in period_records if \"client\" in r.data_category]),\n            \"performance_data_maintained\": len([r for r in period_records if \"performance\" in r.data_category]),\n            \"marketing_materials_reviewed\": len([r for r in period_records if \"marketing\" in r.data_category]),\n            \"compliance_policies_updated\": len([r for r in period_records if \"compliance\" in r.data_category])\n        }\n    \n    def _check_retention_compliance(self, records: List[DataProcessingRecord]) -> Dict[str, Any]:\n        \"\"\"Check retention period compliance for records\"\"\"\n        \n        compliance_summary = {\n            \"compliant_records\": 0,\n            \"non_compliant_records\": 0,\n            \"overdue_deletions\": []\n        }\n        \n        current_time = datetime.now()\n        \n        for record in records:\n            retention_deadline = record.processed_at + timedelta(days=record.retention_period)\n            \n            if current_time > retention_deadline:\n                compliance_summary[\"overdue_deletions\"].append({\n                    \"record_id\": record.record_id,\n                    \"processed_at\": record.processed_at.isoformat(),\n                    \"retention_deadline\": retention_deadline.isoformat(),\n                    \"days_overdue\": (current_time - retention_deadline).days\n                })\n                compliance_summary[\"non_compliant_records\"] += 1\n            else:\n                compliance_summary[\"compliant_records\"] += 1\n        \n        return compliance_summary\n    \n    async def _compliance_monitoring_task(self):\n        \"\"\"Background task for continuous compliance monitoring\"\"\"\n        \n        while True:\n            try:\n                # Check for compliance violations\n                await self._check_retention_violations()\n                await self._check_consent_violations()\n                await self._check_processing_violations()\n                \n                # Sleep for 6 hours\n                await asyncio.sleep(21600)\n                \n            except Exception as e:\n                logger.error(f\"Error in compliance monitoring: {e}\")\n                await asyncio.sleep(3600)\n    \n    async def _data_retention_task(self):\n        \"\"\"Background task for data retention enforcement\"\"\"\n        \n        while True:\n            try:\n                current_time = datetime.now()\n                \n                # Check for records that should be deleted\n                for record in list(self.processing_records.values()):\n                    retention_deadline = record.processed_at + timedelta(days=record.retention_period)\n                    \n                    if current_time > retention_deadline:\n                        # Record should be deleted\n                        logger.info(f\"Data retention deadline passed for record {record.record_id}\")\n                        \n                        # In production, trigger actual data deletion\n                        # For now, just log it\n                        security_logger.log_security_event(\n                            event_type=\"DATA_RETENTION_DEADLINE_PASSED\",\n                            level=SecurityEventLevel.INFO,\n                            user_id=record.user_id,\n                            details={\n                                \"record_id\": record.record_id,\n                                \"data_category\": record.data_category,\n                                \"retention_deadline\": retention_deadline.isoformat(),\n                                \"days_overdue\": (current_time - retention_deadline).days\n                            }\n                        )\n                \n                # Sleep for 24 hours\n                await asyncio.sleep(86400)\n                \n            except Exception as e:\n                logger.error(f\"Error in data retention task: {e}\")\n                await asyncio.sleep(3600)\n    \n    async def _consent_expiry_task(self):\n        \"\"\"Background task to handle consent expiry\"\"\"\n        \n        while True:\n            try:\n                current_time = datetime.now()\n                \n                # Check for expired consents\n                for consent in self.consent_records.values():\n                    if (consent.expires_at and \n                        consent.expires_at <= current_time and \n                        consent.withdrawn_at is None):\n                        \n                        # Consent has expired\n                        consent.withdrawn_at = current_time\n                        \n                        security_logger.log_security_event(\n                            event_type=\"CONSENT_EXPIRED\",\n                            level=SecurityEventLevel.WARNING,\n                            user_id=consent.user_id,\n                            details={\n                                \"consent_id\": consent.consent_id,\n                                \"expired_at\": consent.expires_at.isoformat(),\n                                \"purposes\": consent.purposes\n                            }\n                        )\n                        \n                        # Handle the implications of expired consent\n                        await self._handle_consent_withdrawal(consent.user_id, consent.purposes)\n                \n                # Sleep for 1 hour\n                await asyncio.sleep(3600)\n                \n            except Exception as e:\n                logger.error(f\"Error in consent expiry task: {e}\")\n                await asyncio.sleep(1800)\n    \n    async def _check_retention_violations(self):\n        \"\"\"Check for data retention policy violations\"\"\"\n        # Implementation for checking retention violations\n        pass\n    \n    async def _check_consent_violations(self):\n        \"\"\"Check for consent-related violations\"\"\"\n        # Implementation for checking consent violations\n        pass\n    \n    async def _check_processing_violations(self):\n        \"\"\"Check for data processing violations\"\"\"\n        # Implementation for checking processing violations\n        pass\n    \n    def get_compliance_dashboard(self) -> Dict[str, Any]:\n        \"\"\"Get compliance dashboard data\"\"\"\n        \n        current_time = datetime.now()\n        \n        # Basic statistics\n        stats = {\n            \"enabled_regulations\": [reg.value for reg in self.enabled_regulations],\n            \"total_processing_records\": len(self.processing_records),\n            \"total_consent_records\": len(self.consent_records),\n            \"total_violations\": len(self.violation_records),\n            \"total_reports\": len(self.regulatory_reports)\n        }\n        \n        # Recent activity (last 30 days)\n        thirty_days_ago = current_time - timedelta(days=30)\n        \n        recent_processing = [r for r in self.processing_records.values() \n                           if r.processed_at > thirty_days_ago]\n        \n        recent_violations = [v for v in self.violation_records.values() \n                           if v.detected_at > thirty_days_ago]\n        \n        stats.update({\n            \"recent_processing_count\": len(recent_processing),\n            \"recent_violations_count\": len(recent_violations),\n            \"active_consents\": len([c for c in self.consent_records.values() if c.is_valid()]),\n            \"expired_consents\": len([c for c in self.consent_records.values() if not c.is_valid()])\n        })\n        \n        # Violation breakdown\n        violation_breakdown = defaultdict(int)\n        for violation in recent_violations:\n            violation_breakdown[f\"{violation.regulation.value}_{violation.severity}\"] += 1\n        \n        stats[\"violation_breakdown\"] = dict(violation_breakdown)\n        \n        return stats\n\n\n# Global instance\ncompliance_framework = ComplianceFramework()"}}]