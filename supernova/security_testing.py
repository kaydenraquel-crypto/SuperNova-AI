"""
SuperNova AI Security Testing and Vulnerability Assessment Framework
Comprehensive automated security testing with vulnerability scanning and penetration testing
"""

import os
import json
import hashlib
import uuid
import asyncio
import aiohttp
import subprocess
from datetime import datetime, timedelta
from typing import Dict, Any, List, Optional, Set, Tuple, Union
from enum import Enum
from dataclasses import dataclass, asdict, field
import logging
import re
import socket
import ssl
import requests
import tempfile
from pathlib import Path
from collections import defaultdict
import xml.etree.ElementTree as ET

from .security_config import security_settings
from .security_logger import security_logger, SecurityEventLevel, SECURITY_EVENT_TYPES
from .injection_prevention import injection_prevention

logger = logging.getLogger(__name__)


class VulnerabilityType(str, Enum):
    """Types of security vulnerabilities"""
    SQL_INJECTION = "sql_injection"
    XSS = "xss"
    CSRF = "csrf"
    AUTHENTICATION_BYPASS = "authentication_bypass"
    AUTHORIZATION_FLAW = "authorization_flaw"
    INFORMATION_DISCLOSURE = "information_disclosure"
    INSECURE_COMMUNICATION = "insecure_communication"
    WEAK_CRYPTOGRAPHY = "weak_cryptography"
    INJECTION_FLAW = "injection_flaw"
    BROKEN_ACCESS_CONTROL = "broken_access_control"
    SECURITY_MISCONFIGURATION = "security_misconfiguration"
    VULNERABLE_DEPENDENCIES = "vulnerable_dependencies"
    INSUFFICIENT_LOGGING = "insufficient_logging"
    DDOS_VULNERABILITY = "ddos_vulnerability"
    BUSINESS_LOGIC_FLAW = "business_logic_flaw"


class SeverityLevel(str, Enum):
    """Vulnerability severity levels"""
    CRITICAL = "critical"    # 9.0-10.0 CVSS
    HIGH = "high"           # 7.0-8.9 CVSS
    MEDIUM = "medium"       # 4.0-6.9 CVSS
    LOW = "low"            # 0.1-3.9 CVSS
    INFORMATIONAL = "info" # 0.0 CVSS


class TestType(str, Enum):
    """Types of security tests"""
    AUTOMATED_SCAN = "automated_scan"
    PENETRATION_TEST = "penetration_test"
    VULNERABILITY_SCAN = "vulnerability_scan"
    DEPENDENCY_CHECK = "dependency_check"
    CONFIGURATION_AUDIT = "configuration_audit"
    COMPLIANCE_CHECK = "compliance_check"
    LOAD_TESTING = "load_testing"
    FUZZING = "fuzzing"


@dataclass
class Vulnerability:
    """Security vulnerability information"""
    vuln_id: str
    vuln_type: VulnerabilityType
    severity: SeverityLevel
    title: str
    description: str
    affected_component: str
    proof_of_concept: Optional[str] = None
    remediation: Optional[str] = None
    references: List[str] = field(default_factory=list)
    cvss_score: Optional[float] = None
    cvss_vector: Optional[str] = None
    discovered_at: datetime = field(default_factory=datetime.now)
    discovered_by: str = "automated_scanner"
    status: str = "open"  # open, fixed, false_positive, accepted_risk
    
    def to_dict(self) -> Dict[str, Any]:
        result = asdict(self)
        result['discovered_at'] = self.discovered_at.isoformat()
        return result


@dataclass
class SecurityTest:
    """Security test execution record"""
    test_id: str
    test_type: TestType
    target: str
    started_at: datetime
    completed_at: Optional[datetime] = None
    status: str = "running"  # running, completed, failed, cancelled
    vulnerabilities_found: int = 0
    test_config: Dict[str, Any] = field(default_factory=dict)
    results: Dict[str, Any] = field(default_factory=dict)
    
    def duration(self) -> Optional[timedelta]:
        if self.completed_at and self.started_at:
            return self.completed_at - self.started_at
        return None


class SecurityTestingFramework:
    """
    Comprehensive security testing framework with automated vulnerability assessment
    """
    
    def __init__(self):
        self.vulnerabilities: Dict[str, Vulnerability] = {}
        self.security_tests: Dict[str, SecurityTest] = {}
        self.scan_templates = self._initialize_scan_templates()
        self.test_payloads = self._initialize_test_payloads()
        
        # Configuration
        self.base_url = os.getenv('SUPERNOVA_BASE_URL', 'http://localhost:8000')
        self.api_endpoints = self._discover_endpoints()
        self.auth_tokens = {}
        
        # External tools configuration
        self.tools_config = {
            'nmap': {'enabled': self._check_tool_availability('nmap'), 'path': 'nmap'},
            'sqlmap': {'enabled': self._check_tool_availability('sqlmap'), 'path': 'sqlmap'},
            'nikto': {'enabled': self._check_tool_availability('nikto'), 'path': 'nikto'},
            'bandit': {'enabled': self._check_tool_availability('bandit'), 'path': 'bandit'},
            'safety': {'enabled': self._check_tool_availability('safety'), 'path': 'safety'},
            'semgrep': {'enabled': self._check_tool_availability('semgrep'), 'path': 'semgrep'}
        }
        
        # Start background tasks
        asyncio.create_task(self._continuous_monitoring_task())
    
    def _initialize_scan_templates(self) -> Dict[str, Dict[str, Any]]:
        """Initialize security scan templates"""
        return {
            'owasp_top10': {
                'description': 'OWASP Top 10 vulnerability scan',
                'tests': [
                    'sql_injection',
                    'xss',
                    'broken_authentication',
                    'sensitive_data_exposure',
                    'xml_external_entities',
                    'broken_access_control',
                    'security_misconfiguration',
                    'cross_site_request_forgery',
                    'vulnerable_dependencies',
                    'insufficient_logging'
                ]
            },
            'financial_compliance': {
                'description': 'Financial services security scan',
                'tests': [
                    'pci_dss_compliance',
                    'financial_data_protection',
                    'encryption_strength',
                    'authentication_controls',
                    'audit_logging',
                    'data_retention_compliance'
                ]
            },
            'api_security': {
                'description': 'API-specific security testing',
                'tests': [
                    'api_authentication',
                    'api_authorization',
                    'rate_limiting',
                    'input_validation',
                    'output_encoding',
                    'api_versioning_security'
                ]
            },
            'infrastructure': {
                'description': 'Infrastructure security assessment',
                'tests': [
                    'network_services',
                    'ssl_tls_configuration',
                    'server_hardening',
                    'firewall_configuration',
                    'dns_security',
                    'certificate_validation'
                ]
            }
        }
    
    def _initialize_test_payloads(self) -> Dict[str, List[str]]:
        """Initialize security test payloads"""
        return {
            'sql_injection': [
                "' OR '1'='1",\n                "'; DROP TABLE users; --",\n                "' UNION SELECT * FROM information_schema.tables --",\n                "1' AND SLEEP(5) --",\n                "' OR 1=1#",\n                "'; EXEC xp_cmdshell('dir'); --"\n            ],\n            'xss': [\n                "<script>alert('XSS')</script>",\n                "javascript:alert('XSS')",\n                "<img src=x onerror=alert('XSS')>",\n                "<svg onload=alert('XSS')>",\n                "';alert(String.fromCharCode(88,83,83))//",\n                "<iframe src=\"javascript:alert('XSS')\"></iframe>"\n            ],\n            'nosql_injection': [\n                "{'$ne': null}",\n                "{'$regex': '.*'}",\n                "{'$where': 'this.password.match(/.*/)'}",\n                "'; return true; var dummy='"\n            ],\n            'ldap_injection': [\n                "*)(&(password=*))",\n                "*)((|(password=*)",\n                "*)(cn=*))(|(cn=*"\n            ],\n            'command_injection': [\n                "; ls -la",\n                "| whoami",\n                "&& cat /etc/passwd",\n                "`id`",\n                "$(uname -a)"\n            ],\n            'path_traversal': [\n                "../../../etc/passwd",\n                "..\\\\..\\\\..\\\\windows\\\\system32\\\\drivers\\\\etc\\\\hosts",\n                "....//....//....//etc/passwd",\n                "%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd"\n            ]\n        }\n    \n    def _check_tool_availability(self, tool_name: str) -> bool:\n        \"\"\"Check if external security tool is available\"\"\"\n        try:\n            subprocess.run([tool_name, '--help'], \n                         capture_output=True, \n                         check=False, \n                         timeout=10)\n            return True\n        except (subprocess.TimeoutExpired, FileNotFoundError):\n            return False\n    \n    def _discover_endpoints(self) -> List[str]:\n        \"\"\"Discover API endpoints for testing\"\"\"\n        # In production, this would dynamically discover endpoints\n        # For now, return common SuperNova endpoints\n        return [\n            '/api/auth/login',\n            '/api/auth/register',\n            '/api/users/profile',\n            '/api/portfolio/positions',\n            '/api/market/data',\n            '/api/trading/orders',\n            '/api/analytics/performance',\n            '/api/admin/users',\n            '/api/compliance/reports',\n            '/health',\n            '/metrics'\n        ]\n    \n    async def run_comprehensive_scan(\n        self,\n        scan_template: str = 'owasp_top10',\n        target_override: Optional[str] = None\n    ) -> str:\n        \"\"\"Run comprehensive security scan\"\"\"\n        \n        test_id = str(uuid.uuid4())\n        target = target_override or self.base_url\n        \n        template = self.scan_templates.get(scan_template)\n        if not template:\n            raise ValueError(f\"Unknown scan template: {scan_template}\")\n        \n        # Create security test record\n        security_test = SecurityTest(\n            test_id=test_id,\n            test_type=TestType.VULNERABILITY_SCAN,\n            target=target,\n            started_at=datetime.now(),\n            test_config={\n                'template': scan_template,\n                'tests': template['tests']\n            }\n        )\n        \n        self.security_tests[test_id] = security_test\n        \n        try:\n            # Execute tests based on template\n            for test_name in template['tests']:\n                await self._execute_security_test(test_name, target, test_id)\n            \n            security_test.status = 'completed'\n            security_test.completed_at = datetime.now()\n            security_test.vulnerabilities_found = len([\n                v for v in self.vulnerabilities.values() \n                if v.vuln_id.startswith(test_id)\n            ])\n            \n            # Log scan completion\n            security_logger.log_security_event(\n                event_type=\"SECURITY_SCAN_COMPLETED\",\n                level=SecurityEventLevel.INFO,\n                details={\n                    'test_id': test_id,\n                    'template': scan_template,\n                    'vulnerabilities_found': security_test.vulnerabilities_found,\n                    'duration_seconds': security_test.duration().total_seconds() if security_test.duration() else 0\n                }\n            )\n            \n        except Exception as e:\n            security_test.status = 'failed'\n            security_test.results['error'] = str(e)\n            logger.error(f\"Security scan {test_id} failed: {e}\")\n        \n        return test_id\n    \n    async def _execute_security_test(self, test_name: str, target: str, test_id: str):\n        \"\"\"Execute specific security test\"\"\"\n        \n        if test_name == 'sql_injection':\n            await self._test_sql_injection(target, test_id)\n        elif test_name == 'xss':\n            await self._test_xss(target, test_id)\n        elif test_name == 'broken_authentication':\n            await self._test_authentication(target, test_id)\n        elif test_name == 'broken_access_control':\n            await self._test_access_control(target, test_id)\n        elif test_name == 'security_misconfiguration':\n            await self._test_security_configuration(target, test_id)\n        elif test_name == 'vulnerable_dependencies':\n            await self._check_vulnerable_dependencies(test_id)\n        elif test_name == 'ssl_tls_configuration':\n            await self._test_ssl_tls(target, test_id)\n        elif test_name == 'rate_limiting':\n            await self._test_rate_limiting(target, test_id)\n        elif test_name == 'input_validation':\n            await self._test_input_validation(target, test_id)\n        # Add more test implementations as needed\n    \n    async def _test_sql_injection(self, target: str, test_id: str):\n        \"\"\"Test for SQL injection vulnerabilities\"\"\"\n        \n        vulnerable_endpoints = []\n        \n        for endpoint in self.api_endpoints:\n            for payload in self.test_payloads['sql_injection']:\n                try:\n                    # Test GET parameters\n                    async with aiohttp.ClientSession(timeout=aiohttp.ClientTimeout(total=10)) as session:\n                        test_url = f\"{target}{endpoint}?id={payload}\"\n                        async with session.get(test_url) as response:\n                            response_text = await response.text()\n                            \n                            # Check for SQL error messages\n                            sql_errors = [\n                                'sql syntax error',\n                                'mysql_fetch',\n                                'ora-[0-9]',\n                                'postgresql error',\n                                'sqlite3.operationalerror'\n                            ]\n                            \n                            for error_pattern in sql_errors:\n                                if re.search(error_pattern, response_text, re.IGNORECASE):\n                                    vuln_id = f\"{test_id}_sqli_{len(vulnerable_endpoints)}\"\n                                    \n                                    vulnerability = Vulnerability(\n                                        vuln_id=vuln_id,\n                                        vuln_type=VulnerabilityType.SQL_INJECTION,\n                                        severity=SeverityLevel.HIGH,\n                                        title=f\"SQL Injection in {endpoint}\",\n                                        description=f\"Endpoint {endpoint} is vulnerable to SQL injection\",\n                                        affected_component=endpoint,\n                                        proof_of_concept=f\"GET {test_url}\",\n                                        remediation=\"Use parameterized queries and input validation\"\n                                    )\n                                    \n                                    self.vulnerabilities[vuln_id] = vulnerability\n                                    vulnerable_endpoints.append(endpoint)\n                                    break\n                \n                except Exception as e:\n                    logger.debug(f\"Error testing SQL injection on {endpoint}: {e}\")\n                    continue\n        \n        logger.info(f\"SQL injection test completed. Found {len(vulnerable_endpoints)} vulnerable endpoints.\")\n    \n    async def _test_xss(self, target: str, test_id: str):\n        \"\"\"Test for Cross-Site Scripting vulnerabilities\"\"\"\n        \n        vulnerable_endpoints = []\n        \n        for endpoint in self.api_endpoints:\n            for payload in self.test_payloads['xss']:\n                try:\n                    # Test both GET and POST parameters\n                    async with aiohttp.ClientSession(timeout=aiohttp.ClientTimeout(total=10)) as session:\n                        # Test GET\n                        test_url = f\"{target}{endpoint}?q={payload}\"\n                        async with session.get(test_url) as response:\n                            response_text = await response.text()\n                            \n                            # Check if payload is reflected without encoding\n                            if payload in response_text and 'text/html' in response.headers.get('content-type', ''):\n                                vuln_id = f\"{test_id}_xss_{len(vulnerable_endpoints)}\"\n                                \n                                vulnerability = Vulnerability(\n                                    vuln_id=vuln_id,\n                                    vuln_type=VulnerabilityType.XSS,\n                                    severity=SeverityLevel.MEDIUM,\n                                    title=f\"Cross-Site Scripting in {endpoint}\",\n                                    description=f\"Endpoint {endpoint} reflects user input without proper encoding\",\n                                    affected_component=endpoint,\n                                    proof_of_concept=f\"GET {test_url}\",\n                                    remediation=\"Implement proper output encoding and Content Security Policy\"\n                                )\n                                \n                                self.vulnerabilities[vuln_id] = vulnerability\n                                vulnerable_endpoints.append(endpoint)\n                \n                except Exception as e:\n                    logger.debug(f\"Error testing XSS on {endpoint}: {e}\")\n                    continue\n        \n        logger.info(f\"XSS test completed. Found {len(vulnerable_endpoints)} vulnerable endpoints.\")\n    \n    async def _test_authentication(self, target: str, test_id: str):\n        \"\"\"Test authentication mechanisms\"\"\"\n        \n        vulnerabilities = []\n        \n        # Test authentication bypass attempts\n        auth_endpoints = [ep for ep in self.api_endpoints if 'auth' in ep or 'login' in ep]\n        \n        for endpoint in auth_endpoints:\n            try:\n                async with aiohttp.ClientSession() as session:\n                    # Test with common bypass payloads\n                    bypass_attempts = [\n                        {'username': 'admin', 'password': \"' OR '1'='1\"},\n                        {'username': 'admin', 'password': 'admin'},\n                        {'username': 'root', 'password': 'root'},\n                        {'username': '', 'password': ''},\n                    ]\n                    \n                    for attempt in bypass_attempts:\n                        async with session.post(f\"{target}{endpoint}\", json=attempt) as response:\n                            if response.status == 200:\n                                response_data = await response.json()\n                                \n                                # Check for successful authentication indicators\n                                if any(key in response_data for key in ['token', 'session', 'authenticated']):\n                                    vuln_id = f\"{test_id}_auth_bypass_{len(vulnerabilities)}\"\n                                    \n                                    vulnerability = Vulnerability(\n                                        vuln_id=vuln_id,\n                                        vuln_type=VulnerabilityType.AUTHENTICATION_BYPASS,\n                                        severity=SeverityLevel.CRITICAL,\n                                        title=f\"Authentication Bypass in {endpoint}\",\n                                        description=\"Weak authentication allows bypass with common credentials\",\n                                        affected_component=endpoint,\n                                        proof_of_concept=f\"POST {target}{endpoint} with {attempt}\",\n                                        remediation=\"Implement strong authentication controls and account lockout\"\n                                    )\n                                    \n                                    self.vulnerabilities[vuln_id] = vulnerability\n                                    vulnerabilities.append(vulnerability)\n                                    break\n            \n            except Exception as e:\n                logger.debug(f\"Error testing authentication on {endpoint}: {e}\")\n                continue\n        \n        # Test for weak password policies\n        await self._test_password_policy(target, test_id)\n        \n        logger.info(f\"Authentication test completed. Found {len(vulnerabilities)} vulnerabilities.\")\n    \n    async def _test_access_control(self, target: str, test_id: str):\n        \"\"\"Test access control mechanisms\"\"\"\n        \n        vulnerabilities = []\n        \n        # Test for insecure direct object references\n        protected_endpoints = [ep for ep in self.api_endpoints if any(x in ep for x in ['admin', 'user', 'profile'])]\n        \n        for endpoint in protected_endpoints:\n            try:\n                async with aiohttp.ClientSession() as session:\n                    # Test access without authentication\n                    async with session.get(f\"{target}{endpoint}\") as response:\n                        if response.status == 200:  # Should return 401/403\n                            vuln_id = f\"{test_id}_access_control_{len(vulnerabilities)}\"\n                            \n                            vulnerability = Vulnerability(\n                                vuln_id=vuln_id,\n                                vuln_type=VulnerabilityType.BROKEN_ACCESS_CONTROL,\n                                severity=SeverityLevel.HIGH,\n                                title=f\"Missing Access Control in {endpoint}\",\n                                description=\"Endpoint accessible without proper authentication\",\n                                affected_component=endpoint,\n                                proof_of_concept=f\"GET {target}{endpoint} (no auth headers)\",\n                                remediation=\"Implement proper authentication and authorization checks\"\n                            )\n                            \n                            self.vulnerabilities[vuln_id] = vulnerability\n                            vulnerabilities.append(vulnerability)\n            \n            except Exception as e:\n                logger.debug(f\"Error testing access control on {endpoint}: {e}\")\n                continue\n        \n        logger.info(f\"Access control test completed. Found {len(vulnerabilities)} vulnerabilities.\")\n    \n    async def _test_security_configuration(self, target: str, test_id: str):\n        \"\"\"Test security configuration\"\"\"\n        \n        vulnerabilities = []\n        \n        try:\n            async with aiohttp.ClientSession() as session:\n                # Check security headers\n                async with session.get(target) as response:\n                    headers = response.headers\n                    \n                    security_headers = {\n                        'X-Content-Type-Options': 'nosniff',\n                        'X-Frame-Options': ['DENY', 'SAMEORIGIN'],\n                        'X-XSS-Protection': '1; mode=block',\n                        'Strict-Transport-Security': 'max-age=',\n                        'Content-Security-Policy': None\n                    }\n                    \n                    for header, expected in security_headers.items():\n                        header_value = headers.get(header, '')\n                        \n                        if not header_value:\n                            vuln_id = f\"{test_id}_missing_header_{len(vulnerabilities)}\"\n                            \n                            vulnerability = Vulnerability(\n                                vuln_id=vuln_id,\n                                vuln_type=VulnerabilityType.SECURITY_MISCONFIGURATION,\n                                severity=SeverityLevel.MEDIUM,\n                                title=f\"Missing Security Header: {header}\",\n                                description=f\"Security header {header} is not set\",\n                                affected_component=\"HTTP Headers\",\n                                remediation=f\"Add {header} header to all HTTP responses\"\n                            )\n                            \n                            self.vulnerabilities[vuln_id] = vulnerability\n                            vulnerabilities.append(vulnerability)\n                        \n                        elif expected and isinstance(expected, list):\n                            if not any(exp in header_value for exp in expected):\n                                vuln_id = f\"{test_id}_weak_header_{len(vulnerabilities)}\"\n                                \n                                vulnerability = Vulnerability(\n                                    vuln_id=vuln_id,\n                                    vuln_type=VulnerabilityType.SECURITY_MISCONFIGURATION,\n                                    severity=SeverityLevel.LOW,\n                                    title=f\"Weak Security Header: {header}\",\n                                    description=f\"Security header {header} has weak configuration\",\n                                    affected_component=\"HTTP Headers\",\n                                    remediation=f\"Strengthen {header} header configuration\"\n                                )\n                                \n                                self.vulnerabilities[vuln_id] = vulnerability\n                                vulnerabilities.append(vulnerability)\n        \n        except Exception as e:\n            logger.error(f\"Error testing security configuration: {e}\")\n        \n        logger.info(f\"Security configuration test completed. Found {len(vulnerabilities)} issues.\")\n    \n    async def _check_vulnerable_dependencies(self, test_id: str):\n        \"\"\"Check for vulnerable dependencies\"\"\"\n        \n        vulnerabilities = []\n        \n        if self.tools_config['safety']['enabled']:\n            try:\n                # Run safety check\n                result = subprocess.run(\n                    ['safety', 'check', '--json'],\n                    capture_output=True,\n                    text=True,\n                    timeout=300\n                )\n                \n                if result.returncode != 0 and result.stdout:\n                    safety_results = json.loads(result.stdout)\n                    \n                    for vuln in safety_results:\n                        vuln_id = f\"{test_id}_dep_{len(vulnerabilities)}\"\n                        \n                        vulnerability = Vulnerability(\n                            vuln_id=vuln_id,\n                            vuln_type=VulnerabilityType.VULNERABLE_DEPENDENCIES,\n                            severity=SeverityLevel.HIGH if vuln.get('severity', '') == 'high' else SeverityLevel.MEDIUM,\n                            title=f\"Vulnerable Dependency: {vuln.get('package_name', 'Unknown')}\",\n                            description=vuln.get('advisory', 'Vulnerable package detected'),\n                            affected_component=f\"Package: {vuln.get('package_name', 'Unknown')}\",\n                            remediation=f\"Update to version {vuln.get('fixed_versions', ['latest'])[0]}\",\n                            references=[vuln.get('cve', '')]\n                        )\n                        \n                        self.vulnerabilities[vuln_id] = vulnerability\n                        vulnerabilities.append(vulnerability)\n            \n            except (subprocess.TimeoutExpired, json.JSONDecodeError, Exception) as e:\n                logger.error(f\"Error running safety check: {e}\")\n        \n        logger.info(f\"Dependency check completed. Found {len(vulnerabilities)} vulnerable dependencies.\")\n    \n    async def _test_ssl_tls(self, target: str, test_id: str):\n        \"\"\"Test SSL/TLS configuration\"\"\"\n        \n        vulnerabilities = []\n        \n        if not target.startswith('https://'):\n            vuln_id = f\"{test_id}_no_ssl\"\n            \n            vulnerability = Vulnerability(\n                vuln_id=vuln_id,\n                vuln_type=VulnerabilityType.INSECURE_COMMUNICATION,\n                severity=SeverityLevel.MEDIUM,\n                title=\"Insecure HTTP Communication\",\n                description=\"Application not using HTTPS\",\n                affected_component=\"Transport Layer\",\n                remediation=\"Enable HTTPS with proper SSL/TLS configuration\"\n            )\n            \n            self.vulnerabilities[vuln_id] = vulnerability\n            vulnerabilities.append(vulnerability)\n            return\n        \n        try:\n            # Extract hostname and port\n            from urllib.parse import urlparse\n            parsed = urlparse(target)\n            hostname = parsed.hostname\n            port = parsed.port or 443\n            \n            # Check SSL configuration\n            context = ssl.create_default_context()\n            \n            with socket.create_connection((hostname, port), timeout=10) as sock:\n                with context.wrap_socket(sock, server_hostname=hostname) as ssock:\n                    cert = ssock.getpeercert()\n                    cipher = ssock.cipher()\n                    \n                    # Check for weak ciphers\n                    weak_ciphers = ['RC4', 'DES', 'MD5']\n                    if cipher and any(weak in str(cipher) for weak in weak_ciphers):\n                        vuln_id = f\"{test_id}_weak_cipher\"\n                        \n                        vulnerability = Vulnerability(\n                            vuln_id=vuln_id,\n                            vuln_type=VulnerabilityType.WEAK_CRYPTOGRAPHY,\n                            severity=SeverityLevel.MEDIUM,\n                            title=\"Weak SSL Cipher\",\n                            description=f\"Weak cipher in use: {cipher}\",\n                            affected_component=\"SSL/TLS Configuration\",\n                            remediation=\"Configure strong cipher suites only\"\n                        )\n                        \n                        self.vulnerabilities[vuln_id] = vulnerability\n                        vulnerabilities.append(vulnerability)\n                    \n                    # Check certificate expiration\n                    if cert:\n                        not_after = datetime.strptime(cert['notAfter'], '%b %d %H:%M:%S %Y %Z')\n                        days_until_expiry = (not_after - datetime.now()).days\n                        \n                        if days_until_expiry < 30:\n                            vuln_id = f\"{test_id}_cert_expiry\"\n                            \n                            severity = SeverityLevel.HIGH if days_until_expiry < 7 else SeverityLevel.MEDIUM\n                            \n                            vulnerability = Vulnerability(\n                                vuln_id=vuln_id,\n                                vuln_type=VulnerabilityType.SECURITY_MISCONFIGURATION,\n                                severity=severity,\n                                title=\"SSL Certificate Expiring Soon\",\n                                description=f\"Certificate expires in {days_until_expiry} days\",\n                                affected_component=\"SSL Certificate\",\n                                remediation=\"Renew SSL certificate before expiration\"\n                            )\n                            \n                            self.vulnerabilities[vuln_id] = vulnerability\n                            vulnerabilities.append(vulnerability)\n        \n        except Exception as e:\n            logger.error(f\"Error testing SSL/TLS configuration: {e}\")\n        \n        logger.info(f\"SSL/TLS test completed. Found {len(vulnerabilities)} issues.\")\n    \n    async def _test_rate_limiting(self, target: str, test_id: str):\n        \"\"\"Test rate limiting implementation\"\"\"\n        \n        vulnerabilities = []\n        \n        # Test rate limiting on key endpoints\n        critical_endpoints = [ep for ep in self.api_endpoints if any(x in ep for x in ['auth', 'login', 'api'])]\n        \n        for endpoint in critical_endpoints[:3]:  # Limit testing to avoid DoS\n            try:\n                async with aiohttp.ClientSession() as session:\n                    # Send rapid requests\n                    tasks = []\n                    for _ in range(50):  # Send 50 rapid requests\n                        task = session.get(f\"{target}{endpoint}\")\n                        tasks.append(task)\n                    \n                    responses = await asyncio.gather(*tasks, return_exceptions=True)\n                    \n                    # Check if any requests succeeded (should be rate limited)\n                    successful_requests = sum(1 for r in responses \n                                           if not isinstance(r, Exception) and r.status != 429)\n                    \n                    if successful_requests > 30:  # More than 60% succeeded\n                        vuln_id = f\"{test_id}_rate_limit_{len(vulnerabilities)}\"\n                        \n                        vulnerability = Vulnerability(\n                            vuln_id=vuln_id,\n                            vuln_type=VulnerabilityType.DDOS_VULNERABILITY,\n                            severity=SeverityLevel.MEDIUM,\n                            title=f\"Insufficient Rate Limiting on {endpoint}\",\n                            description=f\"Endpoint allows {successful_requests} requests without rate limiting\",\n                            affected_component=endpoint,\n                            remediation=\"Implement proper rate limiting to prevent abuse\"\n                        )\n                        \n                        self.vulnerabilities[vuln_id] = vulnerability\n                        vulnerabilities.append(vulnerability)\n            \n            except Exception as e:\n                logger.debug(f\"Error testing rate limiting on {endpoint}: {e}\")\n                continue\n        \n        logger.info(f\"Rate limiting test completed. Found {len(vulnerabilities)} issues.\")\n    \n    async def _test_input_validation(self, target: str, test_id: str):\n        \"\"\"Test input validation mechanisms\"\"\"\n        \n        vulnerabilities = []\n        \n        # Test various injection payloads\n        for endpoint in self.api_endpoints:\n            for payload_type, payloads in self.test_payloads.items():\n                for payload in payloads[:3]:  # Test first 3 payloads of each type\n                    try:\n                        async with aiohttp.ClientSession(timeout=aiohttp.ClientTimeout(total=5)) as session:\n                            # Test as GET parameter\n                            test_url = f\"{target}{endpoint}?param={payload}\"\n                            async with session.get(test_url) as response:\n                                if response.status == 500:  # Server error might indicate injection\n                                    response_text = await response.text()\n                                    \n                                    # Check for injection indicators\n                                    if any(indicator in response_text.lower() for indicator in \n                                          ['error', 'exception', 'stack trace', 'syntax error']):\n                                        \n                                        vuln_id = f\"{test_id}_input_val_{len(vulnerabilities)}\"\n                                        \n                                        vulnerability = Vulnerability(\n                                            vuln_id=vuln_id,\n                                            vuln_type=VulnerabilityType.INJECTION_FLAW,\n                                            severity=SeverityLevel.HIGH,\n                                            title=f\"Input Validation Issue in {endpoint}\",\n                                            description=f\"Endpoint vulnerable to {payload_type} injection\",\n                                            affected_component=endpoint,\n                                            proof_of_concept=f\"GET {test_url}\",\n                                            remediation=\"Implement comprehensive input validation and sanitization\"\n                                        )\n                                        \n                                        self.vulnerabilities[vuln_id] = vulnerability\n                                        vulnerabilities.append(vulnerability)\n                                        break\n                    \n                    except Exception as e:\n                        logger.debug(f\"Error testing input validation: {e}\")\n                        continue\n        \n        logger.info(f\"Input validation test completed. Found {len(vulnerabilities)} issues.\")\n    \n    async def _test_password_policy(self, target: str, test_id: str):\n        \"\"\"Test password policy enforcement\"\"\"\n        \n        register_endpoints = [ep for ep in self.api_endpoints if 'register' in ep or 'signup' in ep]\n        \n        for endpoint in register_endpoints:\n            weak_passwords = ['123456', 'password', 'admin', '12345678', 'qwerty']\n            \n            for weak_password in weak_passwords:\n                try:\n                    async with aiohttp.ClientSession() as session:\n                        test_data = {\n                            'username': 'testuser',\n                            'password': weak_password,\n                            'email': 'test@example.com'\n                        }\n                        \n                        async with session.post(f\"{target}{endpoint}\", json=test_data) as response:\n                            if response.status == 200 or response.status == 201:\n                                vuln_id = f\"{test_id}_weak_password_policy\"\n                                \n                                vulnerability = Vulnerability(\n                                    vuln_id=vuln_id,\n                                    vuln_type=VulnerabilityType.AUTHENTICATION_BYPASS,\n                                    severity=SeverityLevel.MEDIUM,\n                                    title=\"Weak Password Policy\",\n                                    description=f\"System accepts weak password: {weak_password}\",\n                                    affected_component=endpoint,\n                                    remediation=\"Implement strong password requirements\"\n                                )\n                                \n                                self.vulnerabilities[vuln_id] = vulnerability\n                                break\n                \n                except Exception as e:\n                    logger.debug(f\"Error testing password policy: {e}\")\n                    continue\n    \n    async def run_penetration_test(\n        self,\n        target: Optional[str] = None,\n        test_scope: List[str] = None\n    ) -> str:\n        \"\"\"Run penetration testing suite\"\"\"\n        \n        test_id = str(uuid.uuid4())\n        target = target or self.base_url\n        test_scope = test_scope or ['authentication', 'authorization', 'injection', 'configuration']\n        \n        security_test = SecurityTest(\n            test_id=test_id,\n            test_type=TestType.PENETRATION_TEST,\n            target=target,\n            started_at=datetime.now(),\n            test_config={'scope': test_scope}\n        )\n        \n        self.security_tests[test_id] = security_test\n        \n        try:\n            # Execute penetration tests based on scope\n            if 'authentication' in test_scope:\n                await self._pentest_authentication(target, test_id)\n            \n            if 'authorization' in test_scope:\n                await self._pentest_authorization(target, test_id)\n            \n            if 'injection' in test_scope:\n                await self._pentest_injection_attacks(target, test_id)\n            \n            if 'configuration' in test_scope:\n                await self._pentest_configuration(target, test_id)\n            \n            security_test.status = 'completed'\n            security_test.completed_at = datetime.now()\n            \n        except Exception as e:\n            security_test.status = 'failed'\n            security_test.results['error'] = str(e)\n            logger.error(f\"Penetration test {test_id} failed: {e}\")\n        \n        return test_id\n    \n    async def _pentest_authentication(self, target: str, test_id: str):\n        \"\"\"Penetration testing for authentication\"\"\"\n        # Advanced authentication testing\n        await self._test_authentication(target, test_id)\n        \n        # Additional advanced tests\n        # - Session management\n        # - Multi-factor authentication bypass\n        # - Password reset flaws\n        # - Account enumeration\n        \n    async def _pentest_authorization(self, target: str, test_id: str):\n        \"\"\"Penetration testing for authorization\"\"\"\n        # Advanced authorization testing\n        await self._test_access_control(target, test_id)\n        \n        # Additional advanced tests\n        # - Privilege escalation\n        # - IDOR (Insecure Direct Object Reference)\n        # - Role-based access control bypass\n        \n    async def _pentest_injection_attacks(self, target: str, test_id: str):\n        \"\"\"Advanced injection attack testing\"\"\"\n        # Run all injection tests\n        await self._test_sql_injection(target, test_id)\n        await self._test_input_validation(target, test_id)\n        \n        # Additional advanced injection tests\n        # - Advanced SQL injection techniques\n        # - NoSQL injection\n        # - LDAP injection\n        # - Command injection\n        # - Template injection\n        \n    async def _pentest_configuration(self, target: str, test_id: str):\n        \"\"\"Advanced configuration testing\"\"\"\n        await self._test_security_configuration(target, test_id)\n        await self._test_ssl_tls(target, test_id)\n        \n        # Additional configuration tests\n        # - Information disclosure\n        # - Default credentials\n        # - Directory traversal\n        # - File upload vulnerabilities\n        \n    def run_external_security_scan(self, tool_name: str, target: Optional[str] = None) -> str:\n        \"\"\"Run external security scanning tool\"\"\"\n        \n        if tool_name not in self.tools_config or not self.tools_config[tool_name]['enabled']:\n            raise ValueError(f\"Tool {tool_name} not available\")\n        \n        test_id = str(uuid.uuid4())\n        target = target or self.base_url\n        \n        security_test = SecurityTest(\n            test_id=test_id,\n            test_type=TestType.AUTOMATED_SCAN,\n            target=target,\n            started_at=datetime.now(),\n            test_config={'tool': tool_name}\n        )\n        \n        self.security_tests[test_id] = security_test\n        \n        try:\n            if tool_name == 'nmap':\n                result = self._run_nmap_scan(target)\n            elif tool_name == 'nikto':\n                result = self._run_nikto_scan(target)\n            elif tool_name == 'bandit':\n                result = self._run_bandit_scan()\n            else:\n                raise ValueError(f\"Unsupported tool: {tool_name}\")\n            \n            security_test.results = result\n            security_test.status = 'completed'\n            security_test.completed_at = datetime.now()\n            \n        except Exception as e:\n            security_test.status = 'failed'\n            security_test.results['error'] = str(e)\n            logger.error(f\"External scan {test_id} failed: {e}\")\n        \n        return test_id\n    \n    def _run_nmap_scan(self, target: str) -> Dict[str, Any]:\n        \"\"\"Run Nmap network scan\"\"\"\n        from urllib.parse import urlparse\n        hostname = urlparse(target).hostname\n        \n        result = subprocess.run(\n            ['nmap', '-sS', '-sV', '--script=vuln', '-oX', '-', hostname],\n            capture_output=True,\n            text=True,\n            timeout=600\n        )\n        \n        return {\n            'stdout': result.stdout,\n            'stderr': result.stderr,\n            'returncode': result.returncode\n        }\n    \n    def _run_nikto_scan(self, target: str) -> Dict[str, Any]:\n        \"\"\"Run Nikto web vulnerability scan\"\"\"\n        result = subprocess.run(\n            ['nikto', '-h', target, '-Format', 'json'],\n            capture_output=True,\n            text=True,\n            timeout=1800\n        )\n        \n        return {\n            'stdout': result.stdout,\n            'stderr': result.stderr,\n            'returncode': result.returncode\n        }\n    \n    def _run_bandit_scan(self) -> Dict[str, Any]:\n        \"\"\"Run Bandit static code analysis\"\"\"\n        result = subprocess.run(\n            ['bandit', '-r', '.', '-f', 'json'],\n            capture_output=True,\n            text=True,\n            timeout=300\n        )\n        \n        return {\n            'stdout': result.stdout,\n            'stderr': result.stderr,\n            'returncode': result.returncode\n        }\n    \n    async def _continuous_monitoring_task(self):\n        \"\"\"Background task for continuous security monitoring\"\"\"\n        \n        while True:\n            try:\n                # Run automated security checks periodically\n                logger.info(\"Running continuous security monitoring\")\n                \n                # Quick vulnerability scan every 6 hours\n                await self.run_comprehensive_scan('api_security')\n                \n                # Check for new vulnerabilities in dependencies daily\n                if datetime.now().hour == 2:  # Run at 2 AM\n                    test_id = str(uuid.uuid4())\n                    await self._check_vulnerable_dependencies(test_id)\n                \n                await asyncio.sleep(21600)  # Sleep for 6 hours\n                \n            except Exception as e:\n                logger.error(f\"Error in continuous monitoring: {e}\")\n                await asyncio.sleep(3600)  # Retry in 1 hour on error\n    \n    def get_vulnerability_report(self, test_id: Optional[str] = None) -> Dict[str, Any]:\n        \"\"\"Generate vulnerability assessment report\"\"\"\n        \n        if test_id:\n            vulnerabilities = [v for v in self.vulnerabilities.values() \n                             if v.vuln_id.startswith(test_id)]\n        else:\n            vulnerabilities = list(self.vulnerabilities.values())\n        \n        # Categorize by severity\n        severity_counts = defaultdict(int)\n        type_counts = defaultdict(int)\n        \n        for vuln in vulnerabilities:\n            severity_counts[vuln.severity.value] += 1\n            type_counts[vuln.vuln_type.value] += 1\n        \n        # Calculate risk score\n        risk_score = (\n            severity_counts['critical'] * 10 +\n            severity_counts['high'] * 7 +\n            severity_counts['medium'] * 4 +\n            severity_counts['low'] * 1\n        )\n        \n        return {\n            'report_id': str(uuid.uuid4()),\n            'generated_at': datetime.now().isoformat(),\n            'test_id': test_id,\n            'summary': {\n                'total_vulnerabilities': len(vulnerabilities),\n                'risk_score': risk_score,\n                'severity_distribution': dict(severity_counts),\n                'vulnerability_types': dict(type_counts)\n            },\n            'vulnerabilities': [vuln.to_dict() for vuln in vulnerabilities],\n            'recommendations': self._generate_security_recommendations(vulnerabilities)\n        }\n    \n    def _generate_security_recommendations(self, vulnerabilities: List[Vulnerability]) -> List[str]:\n        \"\"\"Generate security recommendations based on found vulnerabilities\"\"\"\n        \n        recommendations = []\n        vuln_types = set(v.vuln_type for v in vulnerabilities)\n        \n        if VulnerabilityType.SQL_INJECTION in vuln_types:\n            recommendations.append(\n                \"Implement parameterized queries and input validation to prevent SQL injection\"\n            )\n        \n        if VulnerabilityType.XSS in vuln_types:\n            recommendations.append(\n                \"Implement Content Security Policy (CSP) and proper output encoding\"\n            )\n        \n        if VulnerabilityType.AUTHENTICATION_BYPASS in vuln_types:\n            recommendations.append(\n                \"Strengthen authentication mechanisms and implement account lockout policies\"\n            )\n        \n        if VulnerabilityType.BROKEN_ACCESS_CONTROL in vuln_types:\n            recommendations.append(\n                \"Implement proper authorization checks on all protected endpoints\"\n            )\n        \n        if VulnerabilityType.SECURITY_MISCONFIGURATION in vuln_types:\n            recommendations.append(\n                \"Review and harden security configuration, implement security headers\"\n            )\n        \n        if VulnerabilityType.VULNERABLE_DEPENDENCIES in vuln_types:\n            recommendations.append(\n                \"Update all dependencies to latest secure versions, implement dependency monitoring\"\n            )\n        \n        return recommendations\n    \n    def get_security_metrics(self) -> Dict[str, Any]:\n        \"\"\"Get security testing metrics\"\"\"\n        \n        total_tests = len(self.security_tests)\n        completed_tests = len([t for t in self.security_tests.values() if t.status == 'completed'])\n        total_vulnerabilities = len(self.vulnerabilities)\n        \n        # Vulnerability trends (last 30 days)\n        thirty_days_ago = datetime.now() - timedelta(days=30)\n        recent_vulnerabilities = [v for v in self.vulnerabilities.values() \n                                if v.discovered_at > thirty_days_ago]\n        \n        return {\n            'total_security_tests': total_tests,\n            'completed_tests': completed_tests,\n            'success_rate': (completed_tests / max(1, total_tests)) * 100,\n            'total_vulnerabilities': total_vulnerabilities,\n            'recent_vulnerabilities': len(recent_vulnerabilities),\n            'critical_vulnerabilities': len([v for v in self.vulnerabilities.values() \n                                           if v.severity == SeverityLevel.CRITICAL]),\n            'high_vulnerabilities': len([v for v in self.vulnerabilities.values() \n                                       if v.severity == SeverityLevel.HIGH]),\n            'tools_available': {name: config['enabled'] \n                              for name, config in self.tools_config.items()},\n            'last_scan': max([t.started_at for t in self.security_tests.values()], \n                           default=datetime.min).isoformat()\n        }\n\n\n# Global instance\nsecurity_testing_framework = SecurityTestingFramework()"}}]