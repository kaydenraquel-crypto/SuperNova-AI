"""
SuperNova AI Advanced Field-Level Encryption and Data Protection System
Comprehensive data protection with format-preserving encryption, tokenization,
and compliance-grade security measures
"""

import os
import json
import base64
import hashlib
import secrets
import hmac
from typing import Any, Dict, List, Optional, Union, Tuple, Set
from datetime import datetime, timedelta
from enum import Enum
import logging
import re
from dataclasses import dataclass, asdict
import asyncio
from functools import lru_cache

from cryptography.fernet import Fernet, MultiFernet
from cryptography.hazmat.primitives import hashes, serialization, padding as crypto_padding
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC, PBKDF2HMAC
from cryptography.hazmat.primitives.kdf.hkdf import HKDF
from cryptography.hazmat.primitives.asymmetric import rsa, padding
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.primitives.ciphers.aead import AESGCM, ChaCha20Poly1305
from cryptography.hazmat.backends import default_backend
import cryptography.hazmat.primitives.constant_time as ct

from .security_config import security_settings, SENSITIVE_FIELD_PATTERNS
from .security_logger import security_logger, SecurityEventLevel, SECURITY_EVENT_TYPES

logger = logging.getLogger(__name__)


class EncryptionAlgorithm(str, Enum):
    """Supported encryption algorithms"""
    AES_256_GCM = "aes_256_gcm"
    AES_256_CBC = "aes_256_cbc"
    CHACHA20_POLY1305 = "chacha20_poly1305"
    FERNET = "fernet"
    RSA_OAEP = "rsa_oaep"


class DataClassification(str, Enum):
    """Data classification levels"""
    PUBLIC = "public"
    INTERNAL = "internal"
    CONFIDENTIAL = "confidential"
    RESTRICTED = "restricted"
    TOP_SECRET = "top_secret"


class EncryptionMode(str, Enum):
    """Encryption operation modes"""
    ENCRYPT_ONLY = "encrypt_only"
    DECRYPT_ONLY = "decrypt_only"
    FULL_ACCESS = "full_access"
    TOKENIZE = "tokenize"
    FORMAT_PRESERVING = "format_preserving"


@dataclass
class EncryptionKey:
    """Encryption key metadata and material"""
    key_id: str
    key_type: str
    algorithm: EncryptionAlgorithm
    key_material: bytes
    created_at: datetime
    expires_at: Optional[datetime]
    classification: DataClassification
    usage_count: int = 0
    max_usage: Optional[int] = None
    active: bool = True
    
    def is_expired(self) -> bool:
        return self.expires_at and datetime.now() > self.expires_at
    
    def can_use(self) -> bool:
        return (self.active and 
                not self.is_expired() and 
                (self.max_usage is None or self.usage_count < self.max_usage))


@dataclass
class EncryptedData:
    """Encrypted data container with metadata"""
    ciphertext: bytes
    algorithm: EncryptionAlgorithm
    key_id: str
    nonce: Optional[bytes] = None
    tag: Optional[bytes] = None
    classification: DataClassification = DataClassification.CONFIDENTIAL
    encrypted_at: datetime = None
    additional_data: Optional[bytes] = None
    
    def __post_init__(self):
        if self.encrypted_at is None:
            self.encrypted_at = datetime.now()
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "ciphertext": base64.b64encode(self.ciphertext).decode(),
            "algorithm": self.algorithm.value,
            "key_id": self.key_id,
            "nonce": base64.b64encode(self.nonce).decode() if self.nonce else None,
            "tag": base64.b64encode(self.tag).decode() if self.tag else None,
            "classification": self.classification.value,
            "encrypted_at": self.encrypted_at.isoformat(),
            "additional_data": base64.b64encode(self.additional_data).decode() if self.additional_data else None
        }
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'EncryptedData':
        return cls(
            ciphertext=base64.b64decode(data["ciphertext"]),
            algorithm=EncryptionAlgorithm(data["algorithm"]),
            key_id=data["key_id"],
            nonce=base64.b64decode(data["nonce"]) if data.get("nonce") else None,
            tag=base64.b64decode(data["tag"]) if data.get("tag") else None,
            classification=DataClassification(data.get("classification", "confidential")),
            encrypted_at=datetime.fromisoformat(data["encrypted_at"]),
            additional_data=base64.b64decode(data["additional_data"]) if data.get("additional_data") else None
        )


class AdvancedEncryptionManager:
    """
    Advanced encryption manager with field-level encryption, tokenization,
    and compliance-grade security measures
    """
    
    def __init__(self):
        self.encryption_keys: Dict[str, EncryptionKey] = {}
        self.key_derivation_cache = {}
        self.tokenization_cache: Dict[str, str] = {}
        self.reverse_token_cache: Dict[str, str] = {}
        
        # Load or generate master keys
        self._initialize_master_keys()
        
        # Field classification patterns
        self.field_classifiers = {
            DataClassification.TOP_SECRET: [
                r"ssn", r"social_security", r"tax_id", r"passport",
                r"driver_license", r"private_key", r"master_key"
            ],
            DataClassification.RESTRICTED: [
                r"password", r"secret", r"token", r"api_key", r"credit_card",
                r"bank_account", r"routing_number", r"cvv", r"pin"
            ],
            DataClassification.CONFIDENTIAL: [
                r"salary", r"income", r"net_worth", r"account_balance",
                r"email", r"phone", r"address", r"birth_date"
            ],
            DataClassification.INTERNAL: [
                r"user_id", r"session_id", r"internal_ref", r"employee_id"
            ]
        }\n        \n        # Format preserving encryption patterns\n        self.fpe_patterns = {\n            'credit_card': r'^\d{4}-?\d{4}-?\d{4}-?\d{4}$',\n            'ssn': r'^\d{3}-?\d{2}-?\d{4}$',\n            'phone': r'^(\+?1-?)?\d{3}-?\d{3}-?\d{4}$',\n            'email': r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'\n        }\n        \n        # Key rotation schedule\n        self.key_rotation_intervals = {\n            DataClassification.TOP_SECRET: timedelta(days=30),\n            DataClassification.RESTRICTED: timedelta(days=90),\n            DataClassification.CONFIDENTIAL: timedelta(days=180),\n            DataClassification.INTERNAL: timedelta(days=365)\n        }\n        \n        # Start background tasks\n        asyncio.create_task(self._key_rotation_task())\n        asyncio.create_task(self._audit_encryption_usage())\n    \n    def _initialize_master_keys(self):\n        \"\"\"Initialize or load master encryption keys\"\"\"\n        \n        # Load master key from environment or generate new one\n        master_key_b64 = os.getenv('SUPERNOVA_MASTER_KEY')\n        if master_key_b64:\n            master_key = base64.b64decode(master_key_b64)\n        else:\n            master_key = secrets.token_bytes(32)\n            logger.warning(\"Generated new master key - store securely!\")\n            logger.info(f\"Master key (base64): {base64.b64encode(master_key).decode()}\")\n        \n        # Create master encryption key\n        master_key_obj = EncryptionKey(\n            key_id=\"master_001\",\n            key_type=\"master\",\n            algorithm=EncryptionAlgorithm.AES_256_GCM,\n            key_material=master_key,\n            created_at=datetime.now(),\n            expires_at=None,  # Master keys don't expire\n            classification=DataClassification.TOP_SECRET\n        )\n        \n        self.encryption_keys[\"master_001\"] = master_key_obj\n        \n        # Generate derived keys for different classifications\n        for classification in DataClassification:\n            if classification != DataClassification.PUBLIC:\n                derived_key = self._derive_key(\n                    master_key,\n                    f\"field_encryption_{classification.value}\".encode(),\n                    32\n                )\n                \n                key_obj = EncryptionKey(\n                    key_id=f\"field_{classification.value}_001\",\n                    key_type=\"field\",\n                    algorithm=EncryptionAlgorithm.AES_256_GCM,\n                    key_material=derived_key,\n                    created_at=datetime.now(),\n                    expires_at=datetime.now() + self.key_rotation_intervals[classification],\n                    classification=classification\n                )\n                \n                self.encryption_keys[key_obj.key_id] = key_obj\n    \n    def classify_field(self, field_name: str, field_value: Any = None) -> DataClassification:\n        \"\"\"Classify a field based on its name and optionally its value\"\"\"\n        \n        field_name_lower = field_name.lower()\n        \n        # Check against classification patterns\n        for classification, patterns in self.field_classifiers.items():\n            for pattern in patterns:\n                if re.search(pattern, field_name_lower):\n                    return classification\n        \n        # Value-based classification if field name doesn't match\n        if field_value and isinstance(field_value, str):\n            # Check if looks like credit card\n            if re.match(r'^\d{4}-?\d{4}-?\d{4}-?\d{4}$', field_value):\n                return DataClassification.RESTRICTED\n            \n            # Check if looks like SSN\n            if re.match(r'^\d{3}-?\d{2}-?\d{4}$', field_value):\n                return DataClassification.TOP_SECRET\n            \n            # Check if looks like email\n            if re.match(r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$', field_value):\n                return DataClassification.CONFIDENTIAL\n        \n        return DataClassification.INTERNAL  # Default classification\n    \n    def encrypt_field(\n        self,\n        field_name: str,\n        field_value: Any,\n        classification: Optional[DataClassification] = None,\n        algorithm: Optional[EncryptionAlgorithm] = None,\n        format_preserving: bool = False\n    ) -> EncryptedData:\n        \"\"\"Encrypt a single field with appropriate security level\"\"\"\n        \n        if field_value is None:\n            return None\n        \n        # Auto-classify if not provided\n        if classification is None:\n            classification = self.classify_field(field_name, field_value)\n        \n        # Convert value to bytes\n        if isinstance(field_value, str):\n            plaintext = field_value.encode('utf-8')\n        elif isinstance(field_value, (int, float)):\n            plaintext = str(field_value).encode('utf-8')\n        else:\n            plaintext = json.dumps(field_value, default=str).encode('utf-8')\n        \n        # Select appropriate algorithm\n        if algorithm is None:\n            if classification in [DataClassification.TOP_SECRET, DataClassification.RESTRICTED]:\n                algorithm = EncryptionAlgorithm.AES_256_GCM\n            else:\n                algorithm = EncryptionAlgorithm.FERNET\n        \n        # Get encryption key\n        key_obj = self._get_field_encryption_key(classification)\n        if not key_obj or not key_obj.can_use():\n            raise EncryptionError(f\"No valid encryption key available for {classification}\")\n        \n        # Perform encryption\n        try:\n            if format_preserving and self._supports_format_preserving(field_value):\n                encrypted_data = self._encrypt_format_preserving(plaintext, key_obj, field_name)\n            else:\n                encrypted_data = self._encrypt_with_algorithm(plaintext, key_obj, algorithm)\n            \n            encrypted_data.classification = classification\n            \n            # Update key usage\n            key_obj.usage_count += 1\n            \n            # Log encryption event\n            security_logger.log_security_event(\n                event_type=SECURITY_EVENT_TYPES[\"DATA_ACCESS\"],\n                level=SecurityEventLevel.INFO,\n                details={\n                    \"operation\": \"encrypt_field\",\n                    \"field_name\": field_name,\n                    \"classification\": classification.value,\n                    \"algorithm\": algorithm.value,\n                    \"key_id\": key_obj.key_id\n                }\n            )\n            \n            return encrypted_data\n            \n        except Exception as e:\n            security_logger.log_security_event(\n                event_type=SECURITY_EVENT_TYPES[\"ENCRYPTION_ERROR\"],\n                level=SecurityEventLevel.ERROR,\n                details={\n                    \"operation\": \"encrypt_field\",\n                    \"field_name\": field_name,\n                    \"error\": str(e)\n                }\n            )\n            raise EncryptionError(f\"Failed to encrypt field {field_name}: {str(e)}\")\n    \n    def decrypt_field(\n        self,\n        encrypted_data: EncryptedData,\n        field_name: str,\n        expected_type: type = str\n    ) -> Any:\n        \"\"\"Decrypt a field and convert back to expected type\"\"\"\n        \n        if encrypted_data is None:\n            return None\n        \n        # Get decryption key\n        key_obj = self.encryption_keys.get(encrypted_data.key_id)\n        if not key_obj:\n            raise DecryptionError(f\"Decryption key {encrypted_data.key_id} not found\")\n        \n        try:\n            # Decrypt based on algorithm\n            if encrypted_data.algorithm == EncryptionAlgorithm.AES_256_GCM:\n                plaintext = self._decrypt_aes_gcm(encrypted_data, key_obj)\n            elif encrypted_data.algorithm == EncryptionAlgorithm.CHACHA20_POLY1305:\n                plaintext = self._decrypt_chacha20(encrypted_data, key_obj)\n            elif encrypted_data.algorithm == EncryptionAlgorithm.FERNET:\n                plaintext = self._decrypt_fernet(encrypted_data, key_obj)\n            else:\n                raise DecryptionError(f\"Unsupported algorithm: {encrypted_data.algorithm}\")\n            \n            # Convert back to expected type\n            decrypted_value = plaintext.decode('utf-8')\n            \n            if expected_type == str:\n                result = decrypted_value\n            elif expected_type == int:\n                result = int(decrypted_value)\n            elif expected_type == float:\n                result = float(decrypted_value)\n            elif expected_type in (dict, list):\n                result = json.loads(decrypted_value)\n            else:\n                result = decrypted_value\n            \n            # Log decryption event\n            security_logger.log_security_event(\n                event_type=SECURITY_EVENT_TYPES[\"DATA_ACCESS\"],\n                level=SecurityEventLevel.INFO,\n                details={\n                    \"operation\": \"decrypt_field\",\n                    \"field_name\": field_name,\n                    \"classification\": encrypted_data.classification.value,\n                    \"key_id\": encrypted_data.key_id\n                }\n            )\n            \n            return result\n            \n        except Exception as e:\n            security_logger.log_security_event(\n                event_type=SECURITY_EVENT_TYPES[\"ENCRYPTION_ERROR\"],\n                level=SecurityEventLevel.ERROR,\n                details={\n                    \"operation\": \"decrypt_field\",\n                    \"field_name\": field_name,\n                    \"error\": str(e)\n                }\n            )\n            raise DecryptionError(f\"Failed to decrypt field {field_name}: {str(e)}\")\n    \n    def encrypt_object(\n        self,\n        data_object: Dict[str, Any],\n        field_mapping: Optional[Dict[str, DataClassification]] = None\n    ) -> Dict[str, Any]:\n        \"\"\"Encrypt an entire object with field-level encryption\"\"\"\n        \n        if not isinstance(data_object, dict):\n            raise ValueError(\"Data object must be a dictionary\")\n        \n        encrypted_object = {}\n        \n        for field_name, field_value in data_object.items():\n            if field_value is None:\n                encrypted_object[field_name] = None\n                continue\n            \n            # Skip public fields\n            classification = field_mapping.get(field_name) if field_mapping else None\n            if classification is None:\n                classification = self.classify_field(field_name, field_value)\n            \n            if classification == DataClassification.PUBLIC:\n                encrypted_object[field_name] = field_value\n            else:\n                # Encrypt sensitive fields\n                encrypted_data = self.encrypt_field(field_name, field_value, classification)\n                encrypted_object[f\"{field_name}_encrypted\"] = encrypted_data.to_dict()\n                \n                # Optionally keep a tokenized version for searching\n                if self._should_tokenize(field_name, classification):\n                    encrypted_object[f\"{field_name}_token\"] = self.tokenize_value(field_value)\n        \n        return encrypted_object\n    \n    def decrypt_object(\n        self,\n        encrypted_object: Dict[str, Any],\n        field_types: Optional[Dict[str, type]] = None\n    ) -> Dict[str, Any]:\n        \"\"\"Decrypt an encrypted object back to its original form\"\"\"\n        \n        decrypted_object = {}\n        field_types = field_types or {}\n        \n        for field_name, field_value in encrypted_object.items():\n            if field_name.endswith('_encrypted'):\n                # This is an encrypted field\n                original_field = field_name[:-10]  # Remove '_encrypted' suffix\n                expected_type = field_types.get(original_field, str)\n                \n                if isinstance(field_value, dict):\n                    encrypted_data = EncryptedData.from_dict(field_value)\n                    decrypted_object[original_field] = self.decrypt_field(\n                        encrypted_data, original_field, expected_type\n                    )\n            elif not field_name.endswith('_token'):\n                # Regular unencrypted field\n                decrypted_object[field_name] = field_value\n        \n        return decrypted_object\n    \n    def tokenize_value(self, value: Any) -> str:\n        \"\"\"Create a format-preserving token for searchable encryption\"\"\"\n        \n        if value is None:\n            return None\n        \n        value_str = str(value)\n        \n        # Check cache first\n        if value_str in self.tokenization_cache:\n            return self.tokenization_cache[value_str]\n        \n        # Create deterministic token (for consistent searching)\n        master_key = self.encryption_keys[\"master_001\"].key_material\n        token_key = self._derive_key(master_key, b\"tokenization\", 32)\n        \n        # Create HMAC-based token\n        hmac_obj = hmac.new(token_key, value_str.encode('utf-8'), hashlib.sha256)\n        token_bytes = hmac_obj.digest()[:16]  # Use first 16 bytes\n        \n        # Format preserving token generation\n        if re.match(r'^\\d+$', value_str):\n            # Numeric token\n            token = str(int.from_bytes(token_bytes, 'big') % (10 ** len(value_str))).zfill(len(value_str))\n        elif '@' in value_str:\n            # Email-like token\n            local_part = base64.b64encode(token_bytes[:8]).decode().rstrip('=').lower()[:8]\n            domain_part = base64.b64encode(token_bytes[8:]).decode().rstrip('=').lower()[:8]\n            token = f\"{local_part}@{domain_part}.token\"\n        else:\n            # Generic alphanumeric token\n            token = base64.b64encode(token_bytes).decode().rstrip('=')[:len(value_str)]\n        \n        # Cache the token\n        self.tokenization_cache[value_str] = token\n        self.reverse_token_cache[token] = value_str\n        \n        return token\n    \n    def detokenize_value(self, token: str) -> Optional[str]:\n        \"\"\"Reverse a token back to its original value (if cached)\"\"\"\n        return self.reverse_token_cache.get(token)\n    \n    def _encrypt_with_algorithm(\n        self,\n        plaintext: bytes,\n        key_obj: EncryptionKey,\n        algorithm: EncryptionAlgorithm\n    ) -> EncryptedData:\n        \"\"\"Encrypt data using specified algorithm\"\"\"\n        \n        if algorithm == EncryptionAlgorithm.AES_256_GCM:\n            return self._encrypt_aes_gcm(plaintext, key_obj)\n        elif algorithm == EncryptionAlgorithm.CHACHA20_POLY1305:\n            return self._encrypt_chacha20(plaintext, key_obj)\n        elif algorithm == EncryptionAlgorithm.FERNET:\n            return self._encrypt_fernet(plaintext, key_obj)\n        else:\n            raise EncryptionError(f\"Unsupported encryption algorithm: {algorithm}\")\n    \n    def _encrypt_aes_gcm(self, plaintext: bytes, key_obj: EncryptionKey) -> EncryptedData:\n        \"\"\"Encrypt using AES-256-GCM\"\"\"\n        \n        nonce = secrets.token_bytes(12)  # 96-bit nonce for GCM\n        aesgcm = AESGCM(key_obj.key_material)\n        \n        # Use key_id as additional authenticated data\n        aad = key_obj.key_id.encode('utf-8')\n        \n        ciphertext = aesgcm.encrypt(nonce, plaintext, aad)\n        \n        return EncryptedData(\n            ciphertext=ciphertext,\n            algorithm=EncryptionAlgorithm.AES_256_GCM,\n            key_id=key_obj.key_id,\n            nonce=nonce,\n            additional_data=aad\n        )\n    \n    def _decrypt_aes_gcm(self, encrypted_data: EncryptedData, key_obj: EncryptionKey) -> bytes:\n        \"\"\"Decrypt using AES-256-GCM\"\"\"\n        \n        aesgcm = AESGCM(key_obj.key_material)\n        \n        return aesgcm.decrypt(\n            encrypted_data.nonce,\n            encrypted_data.ciphertext,\n            encrypted_data.additional_data\n        )\n    \n    def _encrypt_chacha20(self, plaintext: bytes, key_obj: EncryptionKey) -> EncryptedData:\n        \"\"\"Encrypt using ChaCha20-Poly1305\"\"\"\n        \n        nonce = secrets.token_bytes(12)  # 96-bit nonce\n        chacha = ChaCha20Poly1305(key_obj.key_material)\n        \n        aad = key_obj.key_id.encode('utf-8')\n        ciphertext = chacha.encrypt(nonce, plaintext, aad)\n        \n        return EncryptedData(\n            ciphertext=ciphertext,\n            algorithm=EncryptionAlgorithm.CHACHA20_POLY1305,\n            key_id=key_obj.key_id,\n            nonce=nonce,\n            additional_data=aad\n        )\n    \n    def _decrypt_chacha20(self, encrypted_data: EncryptedData, key_obj: EncryptionKey) -> bytes:\n        \"\"\"Decrypt using ChaCha20-Poly1305\"\"\"\n        \n        chacha = ChaCha20Poly1305(key_obj.key_material)\n        \n        return chacha.decrypt(\n            encrypted_data.nonce,\n            encrypted_data.ciphertext,\n            encrypted_data.additional_data\n        )\n    \n    def _encrypt_fernet(self, plaintext: bytes, key_obj: EncryptionKey) -> EncryptedData:\n        \"\"\"Encrypt using Fernet (includes authentication)\"\"\"\n        \n        # Derive Fernet key from AES key\n        fernet_key = base64.urlsafe_b64encode(key_obj.key_material)\n        fernet = Fernet(fernet_key)\n        \n        ciphertext = fernet.encrypt(plaintext)\n        \n        return EncryptedData(\n            ciphertext=ciphertext,\n            algorithm=EncryptionAlgorithm.FERNET,\n            key_id=key_obj.key_id\n        )\n    \n    def _decrypt_fernet(self, encrypted_data: EncryptedData, key_obj: EncryptionKey) -> bytes:\n        \"\"\"Decrypt using Fernet\"\"\"\n        \n        fernet_key = base64.urlsafe_b64encode(key_obj.key_material)\n        fernet = Fernet(fernet_key)\n        \n        return fernet.decrypt(encrypted_data.ciphertext)\n    \n    def _encrypt_format_preserving(self, plaintext: bytes, key_obj: EncryptionKey, field_name: str) -> EncryptedData:\n        \"\"\"Format-preserving encryption for maintaining data format\"\"\"\n        \n        # Simplified FPE implementation\n        # In production, use a proper FPE library like FF1\n        \n        value_str = plaintext.decode('utf-8')\n        \n        # Generate deterministic \"random\" data based on key and plaintext\n        combined = key_obj.key_material + plaintext\n        pseudo_random = hashlib.sha256(combined).digest()\n        \n        if re.match(r'^\\d+$', value_str):\n            # Numeric FPE\n            num_value = int(value_str)\n            random_int = int.from_bytes(pseudo_random[:8], 'big')\n            encrypted_num = (num_value + random_int) % (10 ** len(value_str))\n            encrypted_str = str(encrypted_num).zfill(len(value_str))\n        elif re.match(r'^[A-Za-z]+$', value_str):\n            # Alphabetic FPE\n            encrypted_chars = []\n            for i, char in enumerate(value_str):\n                if char.isalpha():\n                    shift = pseudo_random[i % len(pseudo_random)] % 26\n                    if char.isupper():\n                        encrypted_char = chr((ord(char) - ord('A') + shift) % 26 + ord('A'))\n                    else:\n                        encrypted_char = chr((ord(char) - ord('a') + shift) % 26 + ord('a'))\n                    encrypted_chars.append(encrypted_char)\n                else:\n                    encrypted_chars.append(char)\n            encrypted_str = ''.join(encrypted_chars)\n        else:\n            # Fall back to regular encryption\n            return self._encrypt_aes_gcm(plaintext, key_obj)\n        \n        # Store the mapping for decryption\n        mapping_key = f\"fpe_{key_obj.key_id}_{hashlib.sha256(plaintext).hexdigest()[:16]}\"\n        self.key_derivation_cache[mapping_key] = value_str\n        \n        return EncryptedData(\n            ciphertext=encrypted_str.encode('utf-8'),\n            algorithm=EncryptionAlgorithm.AES_256_GCM,  # Mark as AES but handle specially\n            key_id=key_obj.key_id,\n            additional_data=mapping_key.encode('utf-8')\n        )\n    \n    @lru_cache(maxsize=128)\n    def _derive_key(self, master_key: bytes, salt: bytes, length: int = 32) -> bytes:\n        \"\"\"Derive a key using PBKDF2\"\"\"\n        \n        kdf = PBKDF2HMAC(\n            algorithm=hashes.SHA256(),\n            length=length,\n            salt=salt,\n            iterations=100000,\n            backend=default_backend()\n        )\n        \n        return kdf.derive(master_key)\n    \n    def _get_field_encryption_key(self, classification: DataClassification) -> Optional[EncryptionKey]:\n        \"\"\"Get appropriate encryption key for field classification\"\"\"\n        \n        # Find active key for classification\n        for key_obj in self.encryption_keys.values():\n            if (key_obj.key_type == \"field\" and \n                key_obj.classification == classification and \n                key_obj.can_use()):\n                return key_obj\n        \n        return None\n    \n    def _supports_format_preserving(self, value: Any) -> bool:\n        \"\"\"Check if value supports format-preserving encryption\"\"\"\n        \n        if not isinstance(value, str):\n            return False\n        \n        # Check against FPE patterns\n        for pattern_name, pattern in self.fpe_patterns.items():\n            if re.match(pattern, value):\n                return True\n        \n        return False\n    \n    def _should_tokenize(self, field_name: str, classification: DataClassification) -> bool:\n        \"\"\"Determine if field should be tokenized for searching\"\"\"\n        \n        # Tokenize fields that might need to be searched\n        searchable_fields = ['email', 'phone', 'user_id', 'account_id']\n        \n        return (field_name.lower() in searchable_fields and \n                classification in [DataClassification.CONFIDENTIAL, DataClassification.INTERNAL])\n    \n    async def _key_rotation_task(self):\n        \"\"\"Background task for automatic key rotation\"\"\"\n        \n        while True:\n            try:\n                current_time = datetime.now()\n                \n                # Check for keys that need rotation\n                keys_to_rotate = []\n                for key_id, key_obj in self.encryption_keys.items():\n                    if (key_obj.key_type == \"field\" and \n                        key_obj.expires_at and \n                        key_obj.expires_at <= current_time):\n                        keys_to_rotate.append(key_id)\n                \n                # Rotate expired keys\n                for key_id in keys_to_rotate:\n                    await self._rotate_key(key_id)\n                \n                # Sleep for an hour before next check\n                await asyncio.sleep(3600)\n                \n            except Exception as e:\n                logger.error(f\"Error in key rotation task: {e}\")\n                await asyncio.sleep(300)  # Retry in 5 minutes on error\n    \n    async def _rotate_key(self, key_id: str):\n        \"\"\"Rotate an encryption key\"\"\"\n        \n        old_key = self.encryption_keys.get(key_id)\n        if not old_key:\n            return\n        \n        logger.info(f\"Rotating encryption key: {key_id}\")\n        \n        # Generate new key\n        master_key = self.encryption_keys[\"master_001\"].key_material\n        new_key_material = self._derive_key(\n            master_key,\n            f\"field_encryption_{old_key.classification.value}_{datetime.now().isoformat()}\".encode(),\n            32\n        )\n        \n        # Create new key object\n        new_key_id = f\"field_{old_key.classification.value}_{int(datetime.now().timestamp())}\"\n        new_key = EncryptionKey(\n            key_id=new_key_id,\n            key_type=\"field\",\n            algorithm=old_key.algorithm,\n            key_material=new_key_material,\n            created_at=datetime.now(),\n            expires_at=datetime.now() + self.key_rotation_intervals[old_key.classification],\n            classification=old_key.classification\n        )\n        \n        # Add new key\n        self.encryption_keys[new_key_id] = new_key\n        \n        # Mark old key as inactive but keep for decryption\n        old_key.active = False\n        \n        # Log key rotation\n        security_logger.log_security_event(\n            event_type=\"KEY_ROTATION\",\n            level=SecurityEventLevel.INFO,\n            details={\n                \"old_key_id\": key_id,\n                \"new_key_id\": new_key_id,\n                \"classification\": old_key.classification.value\n            }\n        )\n    \n    async def _audit_encryption_usage(self):\n        \"\"\"Audit encryption key usage and performance\"\"\"\n        \n        while True:\n            try:\n                # Collect usage statistics\n                usage_stats = {}\n                for key_id, key_obj in self.encryption_keys.items():\n                    usage_stats[key_id] = {\n                        \"usage_count\": key_obj.usage_count,\n                        \"active\": key_obj.active,\n                        \"classification\": key_obj.classification.value,\n                        \"expires_at\": key_obj.expires_at.isoformat() if key_obj.expires_at else None\n                    }\n                \n                # Log usage audit\n                security_logger.log_security_event(\n                    event_type=\"ENCRYPTION_AUDIT\",\n                    level=SecurityEventLevel.INFO,\n                    details={\n                        \"key_usage_stats\": usage_stats,\n                        \"total_keys\": len(self.encryption_keys),\n                        \"active_keys\": sum(1 for k in self.encryption_keys.values() if k.active)\n                    }\n                )\n                \n                # Sleep for 6 hours\n                await asyncio.sleep(21600)\n                \n            except Exception as e:\n                logger.error(f\"Error in encryption audit: {e}\")\n                await asyncio.sleep(3600)\n    \n    def get_encryption_stats(self) -> Dict[str, Any]:\n        \"\"\"Get encryption system statistics\"\"\"\n        \n        active_keys = sum(1 for k in self.encryption_keys.values() if k.active)\n        total_usage = sum(k.usage_count for k in self.encryption_keys.values())\n        \n        classification_stats = {}\n        for classification in DataClassification:\n            classification_keys = [k for k in self.encryption_keys.values() \n                                 if k.classification == classification]\n            classification_stats[classification.value] = {\n                \"total_keys\": len(classification_keys),\n                \"active_keys\": sum(1 for k in classification_keys if k.active),\n                \"total_usage\": sum(k.usage_count for k in classification_keys)\n            }\n        \n        return {\n            \"total_keys\": len(self.encryption_keys),\n            \"active_keys\": active_keys,\n            \"total_usage\": total_usage,\n            \"classification_stats\": classification_stats,\n            \"tokenization_cache_size\": len(self.tokenization_cache)\n        }\n\n\n# Custom exceptions\nclass EncryptionError(Exception):\n    \"\"\"Encryption operation failed\"\"\"\n    pass\n\n\nclass DecryptionError(Exception):\n    \"\"\"Decryption operation failed\"\"\"\n    pass\n\n\n# Global instance\nadvanced_encryption_manager = AdvancedEncryptionManager()"}}]